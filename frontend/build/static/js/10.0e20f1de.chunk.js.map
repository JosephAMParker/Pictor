{"version":3,"file":"static/js/10.0e20f1de.chunk.js","mappings":"4GAmCO,MAAMA,EAoBT,WAAcC,CAAKC,GAERC,OAAAC,eAAeC,KAAM,WAQxB,CACIC,GAAAA,CAAIC,GAEWC,WAAAC,oBAAoB,SAAUJ,KAAKK,aAC9CL,KAAKM,UAAYJ,EACbA,IAEWC,WAAAI,iBAAiB,SAAUP,KAAKK,aAC3CL,KAAKQ,SACT,EAEJC,GAAAA,GAEI,OAAOT,KAAKM,SAAA,IAWxBN,KAAKK,YAAc,KAEVL,KAAKM,YAKVN,KAAKU,gBAGLV,KAAKW,UAAYC,uBAAsB,IAAMZ,KAAKQ,WAAS,EAS/DR,KAAKU,cAAgB,KAEbV,KAAKW,YAELE,qBAAqBb,KAAKW,WAC1BX,KAAKW,UAAY,OAWzBX,KAAKQ,OAAS,KAEN,IAACR,KAAKM,UAEN,OAMA,IAAAQ,EACAC,EAGA,GANJf,KAAKU,gBAMDV,KAAKM,YAAcH,WAAWa,OAE9BF,EAAQX,WAAWc,WACnBF,EAASZ,WAAWe,gBAIxB,CACI,MAAM,YAAEC,EAAA,aAAaC,GAAiBpB,KAAKM,UAEnCQ,EAAAK,EACCJ,EAAAK,CAAA,CAGR,KAAAC,SAASb,OAAOM,EAAOC,GAC5Bf,KAAKsB,QAAO,EAIhBtB,KAAKW,UAAY,KACjBX,KAAKM,UAAY,KACZ,KAAAiB,SAAW1B,EAAQ0B,UAAY,KAQxC,cAAcC,GAECrB,WAAAC,oBAAoB,SAAUJ,KAAKK,aAC9CL,KAAKU,gBACLV,KAAKU,cAAgB,KACrBV,KAAKK,YAAc,KACnBL,KAAKuB,SAAW,KAChBvB,KAAKQ,OAAS,MA3ITb,EAGK8B,UAA+BC,EAAAA,GAAcC,Y,wBCWxD,MAAMC,EAgBT,WAAchC,CAAKC,GAGfA,EAAUC,OAAO+B,OAAO,CACpBC,WAAW,EACXC,cAAc,GACflC,GAGIC,OAAAC,eAAeC,KAAM,SACxB,CACIC,GAAAA,CAAI+B,GAEIhC,KAAKiC,SAELjC,KAAKiC,QAAQC,OAAOlC,KAAKsB,OAAQtB,MAErCA,KAAKiC,QAAUD,EACXA,GAEAA,EAAOG,IAAInC,KAAKsB,OAAQtB,KAAMoC,EAAAA,EAAgBC,IAClD,EAEJ5B,GAAAA,GAEI,OAAOT,KAAKiC,OAAA,IAUxBjC,KAAKsC,KAAO,KAERtC,KAAKiC,QAAQK,MAAK,EAStBtC,KAAKuC,MAAQ,KAETvC,KAAKiC,QAAQM,OAAM,EAUvBvC,KAAKiC,QAAU,KASfjC,KAAKgC,OAASnC,EAAQkC,aAAeS,EAAAA,EAAOC,OAAS,IAAID,EAAAA,EAGrD3C,EAAQiC,WAER9B,KAAKuC,OACT,CAQJ,cAAcf,GAEV,GAAIxB,KAAKiC,QACT,CACI,MAAMS,EAAY1C,KAAKiC,QAEvBjC,KAAKgC,OAAS,KACdU,EAAUlB,SAAQ,CACtB,EAzGKI,EAGKH,UAA+BC,EAAAA,GAAcC,YChD/DgB,EAAAA,GAAWR,IAAIxC,GACfgD,EAAAA,GAAWR,IAAIP,E,8BCKR,MAAMgB,EAaTC,WAAAA,CAAYxB,GAERrB,KAAK8C,UAAYzB,CAAA,CAGd0B,IAAAA,CAAKC,EAAsBC,EAAsBC,GAEhClD,KAAK8C,UAAUK,YAEvBC,MAAMC,MAAMH,GAExBA,EAAef,IAAI,CACfmB,aAAc,SACdC,WAAW,EACXC,OAAQ,aACRP,YACAD,gBACkB,CAGnBS,GAAAA,CAAIC,EAAuBC,EAAuBT,GAErDlD,KAAK8C,UAAUK,YAAYC,MAAMC,MAAMH,GAEvCA,EAAef,IAAI,CACfmB,aAAc,SACdE,OAAQ,YACRD,WAAW,GACd,CAGEK,OAAAA,CAAQC,GAEgB,eAAvBA,EAAYL,OAEP,KAAAV,UAAUgB,OAAOf,KAAKc,GAEC,cAAvBA,EAAYL,QAEZ,KAAAV,UAAUgB,OAAOL,KAC1B,CAGGjC,OAAAA,GAEHxB,KAAK8C,UAAY,MA1DZF,EAEKnB,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcsC,WACdtC,EAAAA,GAAcuC,YACdvC,EAAAA,GAAcwC,aAElBC,KAAM,U,wGCTd,MAAMC,EAAa,IAAIC,EAAAA,EAWP,SAAAC,EAAoBC,EAAmBC,GAoB5C,OAlBPA,EAAOC,QAEPC,EAA0BH,EAAQC,GAE7BA,EAAOG,SAERH,EAAOvE,IAAI,EAAG,EAAG,EAAG,GAGnBsE,EAAOK,YAMDJ,EAAAK,YAAYN,EAAOK,YAAYE,gBAJ/BN,EAAAK,YAAYN,EAAOQ,kBAAkBC,gBAOzCR,CACX,CAEgB,SAAAE,EACZH,EACAC,GAGA,GAAkC,IAA9BD,EAAOU,qBAAiCV,EAAOW,WAE/C,OAGJ,MAAMC,IAAkBZ,EAAOa,QAAQC,OAEvC,IAAIC,EAAcd,EAOlB,IALID,EAAOK,aAAeO,KAERG,EAAAC,EAAAA,EAAW9E,MAAMgE,SAG/BF,EAAOiB,WAEPhB,EAAOiB,QAAQlB,EAAOiB,WAAYjB,EAAOS,oBAG7C,CACI,GAAIT,EAAOjB,aACX,CACI,MAAMoC,EAAcnB,EAAsBC,OAE9Bc,EAAAK,SACRD,EAAWE,KACXF,EAAWG,KACXH,EAAWI,KACXJ,EAAWK,KACXxB,EAAOyB,eACX,CAGJ,MAAMC,EAAW1B,EAAO0B,SAExB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAASZ,OAAQa,IAEPxB,EAAAuB,EAASC,GAAIZ,EAC3C,CAGJ,GAAIH,EACJ,CACI,IAAIgB,GAAW,EAEf,IAAK,IAAID,EAAI,EAAGA,EAAI3B,EAAOa,QAAQC,OAAQa,IAEnC3B,EAAOa,QAAQc,GAAGE,YAEbD,IAEUA,GAAA,EACCb,EAAAT,YAAYN,EAAOQ,kBAAkBC,iBAGrDT,EAAOa,QAAQc,GAAGE,UAAUd,GAAa,IAI7Ca,IAEYb,EAAAT,YAAYN,EAAOQ,kBAAkBC,eAAeqB,OAAOjC,GAAYkC,UAC5E9B,EAAA4B,UAAUd,EAAaf,EAAOgC,yBAGzC/B,EAAO4B,UAAUd,GACjBC,EAAAA,EAAWiB,OAAOlB,EAAW,MAExBf,EAAOK,cAELJ,EAAA4B,UAAUd,EAAaf,EAAOgC,wBACrChB,EAAAA,EAAWiB,OAAOlB,GAE1B,C,aC5FA,MAAMmB,EAAe,IAAIC,EAAAA,EAAS,CAC9BC,WAAY,CACRC,UAAW,CACPC,OAAQ,IAAIC,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC/CC,OAAQ,YACRC,OAAQ,EACRC,OAAQ,IAGhBC,YAAa,IAAIC,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,MAkD1C,MAAMC,EA4BTvE,WAAAA,CAAYxB,GAfZ,KAAQgG,kBAAoB,EAC5B,KAAQC,aAA6B,GAEpB,KAAAC,sBAAwB,IAAIC,EAAAA,EAAa,CACtDC,WAAY,CAAEC,MAAO,IAAIZ,aAAa,GAAI/C,KAAM,aAChD4D,YAAa,CAAED,MAAO,IAAIZ,aAAa,GAAI/C,KAAM,aACjD6D,YAAa,CAAEF,MAAO,IAAIZ,aAAa,GAAI/C,KAAM,aACjD8D,aAAc,CAAEH,MAAO,IAAIZ,aAAa,GAAI/C,KAAM,aAClD+D,aAAc,CAAEJ,MAAO,IAAIZ,aAAa,GAAI/C,KAAM,aAClDgE,eAAgB,CAAEL,MAAO,IAAIZ,aAAa,GAAI/C,KAAM,eAGxD,KAAiBiE,uBAAoC,IAAIC,EAAAA,EAAU,IAK/DjI,KAAKqB,SAAWA,CAAA,CAOpB,qBAAW6G,GAEP,OAAOlI,KAAKmI,mBAAmBC,WAAA,CAG5BrF,IAAAA,CAAKc,GAER,MAAMxC,EAAWrB,KAAKqB,SAEhBgH,EAAUxE,EAAYb,aAAaqF,QAEpCrI,KAAKsH,aAAatH,KAAKqH,qBAExBrH,KAAKsH,aAAatH,KAAKqH,mBAAqBrH,KAAKsI,kBAKrD,MAAMC,EAAavI,KAAKsH,aAAatH,KAAKqH,mBAKtC,GAHC,KAAAA,oBAGkB,IAAnBgB,EAAQhD,OAIR,YAFAkD,EAAWC,MAAO,GAKtB,MAAMhE,EAAiB+D,EAAW/D,OAK9BX,EAAY4E,YC7JR,SAA0BA,EAA2BjE,GAEjEA,EAAOC,QAMP,MAAML,EAAaI,EAAOkE,OAE1B,IAAK,IAAIxC,EAAI,EAAGA,EAAIuC,EAAYpD,OAAQa,IACxC,CACU,MAAAyC,EAAaF,EAAYvC,GAE3ByC,EAAWC,oBAAsB,IAKrCpE,EAAOkE,OAASC,EAAW3D,eAC3B2D,EAAWvC,UAAU5B,GAAM,CAG/BA,EAAOkE,OAAStE,CAGpB,CDqIsCyE,CAAAhF,EAAY4E,YAAajE,GAG9CX,EAAYb,aAAa8F,YAE9BtE,EAAOC,QAGAD,EAAAiB,QAAQ5B,EAAYb,aAAa8F,YAGjCtE,EAAAK,YAAYhB,EAAYZ,UAAU+B,iBAMrBV,EAAAT,EAAYZ,UAAWuB,GAI/C,MAAMuE,EAAqB1H,EAAS2H,aAAaA,aAAaC,aAAaC,OAI3E,IAAIC,EAAaC,IAEbC,EAAU,EAEVC,GAAY,EAEZC,GAAgB,EAEhBC,GAAU,EAEVC,GAAiB,EAErB,IAAK,IAAIvD,EAAI,EAAGA,EAAImC,EAAQhD,OAAQa,IACpC,CACU,MAAApC,EAASuE,EAAQnC,GAEViD,EAAAO,KAAKC,IAAIR,EAAkC,YAAtBrF,EAAOqF,WACnCJ,EAAmBa,YAAc9F,EAAOqF,YAC9CE,GAAWvF,EAAOuF,QAEO,QAArBvF,EAAOwF,UAEKA,GAAA,EAEc,YAArBxF,EAAOwF,WAEZA,IAAAA,EAAcP,EAAmBO,WAGhCxF,EAAO2F,iBAESA,GAAA,GAKrB,OAFwB3F,EAAO+F,oBAAsBxI,EAAS0C,MAG9D,CACcyF,GAAA,EACV,MAGJ,GAAI1F,EAAOyF,iBAAoBlI,EAA2ByI,YAAYC,eAAiB,GACvF,EAGIC,EAAAA,EAAAA,GAAK,wHAGKR,GAAA,EACV,MAGJA,EAAU1F,EAAO0F,SAAWA,EAC5BD,EAAgBA,GAAiBzF,EAAOyF,aAAA,CAI5C,GAAKC,EAAL,CAcA,GAHAhF,EACKyF,MAAMd,GAEPM,EACJ,CACU,MAAAS,EAAW7I,EAAS2H,aAAamB,aAEvC3F,EAAO4F,UAAU,EAAGF,EAASpJ,MAAO,EAAGoJ,EAASnJ,OAAM,CAIrDyD,EAAA6F,OACAJ,MAAM,EAAId,GACVmB,IAAc,EAAVjB,GAIJ7E,EAAO+F,YAQZhC,EAAWC,MAAO,EAElBD,EAAW/D,OAASA,EACpB+D,EAAWgB,cAAgBA,EAC3BhB,EAAWtF,UAAYY,EAAYZ,UACnCsF,EAAWvF,aAAea,EAAYb,aAE3BuF,EAAAiC,sBAAwBnJ,EAAS2H,aAAayB,cAIzDlC,EAAWmC,aAAeC,EAAAA,EAAYC,kBAClCpG,EAAO1D,MACP0D,EAAOzD,OACPoI,EACAG,GAGJjI,EAAS2H,aAAa6B,KAAKtC,EAAWmC,cAAc,GAGpDrJ,EAASyJ,eAAe/H,KAAK,CACzBkE,OAAQzC,KA5BR+D,EAAWC,MAAO,CA1BlB,MAFAD,EAAWC,MAAO,CAyDrB,CAGE/E,GAAAA,GAEH,MAAMpC,EAAWrB,KAAKqB,SAEjB,KAAAgG,oBACL,MAAMkB,EAAavI,KAAKsH,aAAatH,KAAKqH,mBAG1C,GAAIkB,EAAWC,KAEX,OAGJxI,KAAKmI,kBAAoBI,EAEzB,MAAMmC,EAAenC,EAAWmC,aAE1BlG,EAAS+D,EAAW/D,OAE1B,IAAI4D,EAAc2C,EAAAA,EAAQC,MAI1B,GAFA3J,EAAS2H,aAAaiC,mBAElB1C,EAAWgB,cACf,CAGU,MAAA2B,EAAiBlL,KAAKqH,kBAAoB,EAAIrH,KAAKsH,aAAatH,KAAKqH,kBAAoB,GAAG7C,OAAS,KAErGwE,EAAe3H,EAAS2H,aAAamC,gBAAgB5C,EAAWiC,uBAEtEpC,EAAcpI,KAAKoL,eAAepC,EAAcxE,EAAQ0G,EAAc,CAG1E3C,EAAWH,YAAcA,EAEnB,MAAAC,EAAUE,EAAWvF,aAAaqF,QAapC,GALJrI,KAAKgI,uBAAuBqD,YAAYX,EAAaxB,OAAOoC,MAAO,GACnEtL,KAAKgI,uBAAuBqD,YAAYjD,EAAYc,OAAQ,GAE5D7H,EAASyJ,eAAerH,MAED,IAAnB4E,EAAQhD,OAIRgD,EAAQ,GAAGkD,MAAMvL,KAAM0K,EAAcnC,EAAWiC,uBAAuB,GAGvEG,EAAAA,EAAYa,cAAcd,OAG9B,CACI,IAAIe,EAAOlD,EAAWmC,aAGlBgB,EAAOf,EAAAA,EAAYC,kBACnBpG,EAAO1D,MACP0D,EAAOzD,OACP0K,EAAKvC,OAAOU,aACZ,GAGA1D,EAAI,EAGR,IAAKA,EAAI,EAAGA,EAAImC,EAAQhD,OAAS,IAAKa,EACtC,CACmBmC,EAAQnC,GAEhBqF,MAAMvL,KAAMyL,EAAMC,GAAM,GAC/B,MAAMC,EAAIF,EAEHA,EAAAC,EACAA,EAAAC,CAAA,CAGXtD,EAAQnC,GAAGqF,MAAMvL,KAAMyL,EAAMlD,EAAWiC,uBAAuB,GAG/DG,EAAAA,EAAYa,cAAcC,GAC1Bd,EAAAA,EAAYa,cAAcE,EAAI,CAI9BnD,EAAWgB,eAEXoB,EAAAA,EAAYa,cAAcpD,EAC9B,CAGGgD,cAAAA,CAAeQ,EAAiCpH,EAAgB0G,GAE7D,MAAAW,EAAuBD,EAAkB3C,aAAaC,OAAOU,YAE7DxB,EAAcuC,EAAAA,EAAYC,kBAC5BpG,EAAO1D,MACP0D,EAAOzD,OACP8K,GACA,GAGJ,IAAIC,EAAItH,EAAOoB,KACXmG,EAAIvH,EAAOqB,KAEXqF,IAEAY,GAAKZ,EAAetF,KACpBmG,GAAKb,EAAerF,MAGpBiG,EAAApC,KAAKsC,MAAMF,EAAID,GACfE,EAAArC,KAAKsC,MAAMD,EAAIF,GAEnB,MAAM/K,EAAQ4I,KAAKW,KAAK7F,EAAO1D,MAAQ+K,GACjC9K,EAAS2I,KAAKW,KAAK7F,EAAOzD,OAAS8K,GAUlC,OARP7L,KAAKqB,SAAS2H,aAAaiD,cACvBL,EACAxD,EACA,CAAE0D,IAAGC,KACL,CAAEjL,QAAOC,UACT,CAAE+K,EAAG,EAAGC,EAAG,IAGR3D,CAAA,CAGJ8D,WAAAA,CAAYpI,EAAgBqI,EAAgBC,EAAuB3H,GAEtE,MAAMpD,EAAWrB,KAAKqB,SAEhBkH,EAAavI,KAAKsH,aAAatH,KAAKqH,mBAEpC7C,EAAS+D,EAAW/D,OAEpByC,EAASoF,EAAAA,EAAM5J,OAGf6J,EAFwB/D,EAAWiC,wBAEO4B,EAEhD,IAAIjD,EAAanJ,KAAKqB,SAAS2H,aAAauD,iBAAiBtD,aAAaC,OAAOU,YAI7E4C,EAAexM,KAAKqH,kBAAoB,EAE5C,KAAOmF,EAAe,GAAKxM,KAAKsH,aAAakF,GAAchE,QAErDgE,EAGFA,EAAe,IAEfrD,EAAanJ,KAAKsH,aAAakF,GAAc9B,aAAaxB,OAAOU,aAGrE,MAAM6C,EAAiBzM,KAAKuH,sBACtBmF,EAAWD,EAAeC,SAE1BC,EAAcD,EAAS7E,aACvB+E,EAAYF,EAASjF,WACrBoF,EAAaH,EAAS/E,YACtBmF,EAAaJ,EAAS9E,YACtBmF,EAAcL,EAAS5E,aACvBkF,EAAgBN,EAAS3E,eAG/B,GAAIuE,EACJ,CACI,IAAIW,EAAYjN,KAAKqH,kBAGrB,KAAO4F,EAAY,GACnB,CACIA,IACA,MAAMC,EAAalN,KAAKsH,aAAatH,KAAKqH,kBAAoB,GAE1D,IAAC6F,EAAW1E,KAChB,CACWvB,EAAA6E,EAAIoB,EAAW1I,OAAOoB,KACtBqB,EAAA8E,EAAImB,EAAW1I,OAAOqB,KAE7B,MACJ,CAGJ8G,EAAY,GAAKnI,EAAOoB,KAAOqB,EAAO6E,EACtCa,EAAY,GAAKnI,EAAOqB,KAAOoB,EAAO8E,CAAA,MAItCY,EAAY,GAAK,EACjBA,EAAY,GAAK,EAGTA,EAAA,GAAKR,EAAMgB,MAAMrM,MACjB6L,EAAA,GAAKR,EAAMgB,MAAMpM,OAEnB6L,EAAA,GAAKT,EAAMjD,OAAOpI,MAClB8L,EAAA,GAAKT,EAAMjD,OAAOnI,OAC5B6L,EAAU,GAAK,EAAIA,EAAU,GAC7BA,EAAU,GAAK,EAAIA,EAAU,GAElBC,EAAA,GAAKV,EAAMjD,OAAOkE,WAClBP,EAAA,GAAKV,EAAMjD,OAAOmE,YAC7BR,EAAW,GAAK,EAAMA,EAAW,GACjCA,EAAW,GAAK,EAAMA,EAAW,GAEjCC,EAAW,GAAK,GAAMD,EAAW,GACjCC,EAAW,GAAK,GAAMD,EAAW,GACtBC,EAAA,GAAMX,EAAMgB,MAAMrM,MAAQ8L,EAAU,GAAO,GAAMC,EAAW,GAC5DC,EAAA,GAAMX,EAAMgB,MAAMpM,OAAS6L,EAAU,GAAO,GAAMC,EAAW,GAExE,MAAMS,EAActN,KAAKqB,SAAS2H,aAAauD,iBAAiBtD,aAEpD8D,EAAA,GAAK9F,EAAO6E,EAAI3C,EAChB4D,EAAA,GAAK9F,EAAO8E,EAAI5C,EAE5B4D,EAAY,GAAKO,EAAYpE,OAAOpI,MAAQqI,EAC5C4D,EAAY,GAAKO,EAAYpE,OAAOnI,OAASoI,EAI7C,MAAMH,EAAehJ,KAAKqB,SAAS2H,aAAamC,gBAAgBiB,GAoB3D,GAlBL/K,EAAS2H,aAAa6B,KAAKuB,IAAU3H,GAEjC2H,aAAkBrB,EAAAA,GAEJiC,EAAA,GAAKZ,EAAOe,MAAMrM,MAClBkM,EAAA,GAAKZ,EAAOe,MAAMpM,SAKlBiM,EAAA,GAAKhE,EAAalI,MAClBkM,EAAA,GAAKhE,EAAajI,QAGpCiM,EAAc,GAAKhE,EAAauE,QAAc,IAC9Cd,EAAee,SAGVnM,EAA4B8B,YAAYsK,aAC7C,CACI,MAAMC,EAAiBrM,EAA4B8B,YAAYsK,aAC1DE,eAAelB,GAEf,KAAAzE,uBAAuBqD,YAAYqC,EAAe,EAAC,MAInD,KAAA1F,uBAAuBqD,YAAYoB,EAAgB,GAM5DzM,KAAKgI,uBAAuBqD,YAAYc,EAAMjD,OAAQ,GACtDlJ,KAAKgI,uBAAuBqD,YAAYc,EAAMjD,OAAOoC,MAAO,GAErDxH,EAAA8J,OAAO,GAAK5N,KAAKgI,uBAExB3G,EAASwM,QAAQC,KAAK,CAClBC,SAAUtH,EACVuH,OAAQlK,EACRmK,MAAOnK,EAAOoK,OACdC,SAAU,kBAIV9M,EAAS0C,OAASqK,EAAAA,EAAaC,OAE/BhN,EAAS2H,aAAaiC,kBAC1B,CAGI3C,cAAAA,GAEG,OACHE,MAAM,EACNkC,aAAc,KACdlG,OAAQ,IAAI8J,EAAAA,EACZrL,UAAW,KACXD,aAAc,KACduG,eAAe,EACfiB,sBAAuB,KAC3B,CAWG+D,qBAAAA,CAAsBC,EAAsBC,GAE/C,MAAMC,EAAO1O,KAAKmI,kBAEZwG,EAAeH,EAAavO,IAC9ByO,EAAKhE,aAAakE,QAAQ9N,MAC1B,EAAG,EACH4N,EAAKhE,aAAakE,QAAQ7N,OAC1B2N,EAAKlK,OAAOoB,KAAM8I,EAAKlK,OAAOqB,MAG5Bb,EAAiByJ,EAAOzJ,eAAeqB,OAAOhC,EAAAA,EAAO5B,QAWpD,OATPuC,EAAesB,SACfqI,EAAaE,QAAQ7J,GACR2J,EAAA1E,MACT,EAAMwE,EAAOK,QAAQ3B,MAAMrM,MAC3B,EAAM2N,EAAOK,QAAQ3B,MAAMpM,QAG/B4N,EAAaI,UAAUN,EAAOO,OAAOlD,EAAG2C,EAAOO,OAAOjD,GAE/C4C,CAAA,EAniBFvH,EAGK3F,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcuN,YACdvN,EAAAA,GAAcwN,cAElB/K,KAAM,UE5FdxB,EAAAA,GAAWR,IAAIiF,GACfzE,EAAAA,GAAWR,IAAIS,E,oDCLR,MAAMuM,EAAkB,CAC3BhL,KAAM,oBACNiL,OAAQ,CACJC,OAAkB,kQAUlBC,KAAgB,sHAIhBC,IAAe,gMAUVC,EAAwB,IAC9BL,EACHC,OAAQ,IACDD,EAAgBC,OAEnBC,OAAQF,EAAgBC,OAAOC,OAAOI,QAAQ,WAAY,cAIrDC,EAAoB,CAC7BvL,KAAM,oBACNiL,OAAQ,CACJC,OAAkB,gIAMlBC,KAAgB,yFAIhBC,IAAe,sJ,iCC9CvB,MAAMI,EAAe,CACjBC,OAAQ,EACRzN,IAAK,EACL0N,SAAU,EACVC,OAAQ,EACRC,QAAS,EACTC,MAAO,EACP,aAAc,EACd,UAAW,EACX,aAAc,EACdrG,IAAK,EACLsG,IAAK,IAgBIC,EAAN,MAAMA,EAYTrN,WAAAA,GAEI7C,KAAK0O,KAAO,EAEZ1O,KAAKmQ,UAAY,SACjBnQ,KAAKoQ,cAAgB,EAErBpQ,KAAKqQ,OAAQ,EACbrQ,KAAKsQ,WAAY,EAOrB,SAAID,GAEA,SAAuB,EAAbrQ,KAAK0O,KAAa,CAGhC,SAAI2B,CAAM3I,MAEc,EAAb1H,KAAK0O,QAAyBhH,IAEjC1H,KAAK0O,MAAS,EAClB,CAOJ,WAAI6B,GAEA,SAAuB,EAAbvQ,KAAK0O,KAAa,CAGhC,WAAI6B,CAAQ7I,MAEY,EAAb1H,KAAK0O,QAA0BhH,IAElC1H,KAAK0O,MAAS,EAClB,CAIJ,YAAI8B,CAAS9I,GAEK,SAAVA,GAOJ1H,KAAKyQ,SAAU,EACfzQ,KAAK0Q,mBAA+B,UAAVhJ,GANtB1H,KAAKyQ,SAAU,CAMiB,CAGxC,YAAID,GAEI,OAACxQ,KAAKyQ,QAKHzQ,KAAK0Q,mBAAqB,QAAU,OAHhC,MAGgC,CAO/C,WAAID,GAEA,SAAuB,EAAbzQ,KAAK0O,KAAa,CAGhC,WAAI+B,CAAQ/I,MAEY,EAAb1H,KAAK0O,QAA2BhH,IAEnC1H,KAAK0O,MAAS,EAClB,CAOJ,aAAIiC,GAEA,SAAuB,EAAb3Q,KAAK0O,KAAa,CAGhC,aAAIiC,CAAUjJ,MAEU,EAAb1H,KAAK0O,QAA8BhH,IAEtC1H,KAAK0O,MAAS,EAClB,CAOJ,aAAI4B,GAEA,SAAuB,GAAbtQ,KAAK0O,KAAa,CAGhC,aAAI4B,CAAU5I,MAEU,GAAb1H,KAAK0O,QAA8BhH,IAEtC1H,KAAK0O,MAAS,GAClB,CAOJ,sBAAIgC,GAEA,SAAuB,GAAb1Q,KAAK0O,KAAa,CAGhC,sBAAIgC,CAAmBhJ,MAEC,GAAb1H,KAAK0O,QAA2BhH,IAEnC1H,KAAK0O,MAAS,GAClB,CAQJ,aAAIyB,GAEA,OAAOnQ,KAAK4Q,UAAA,CAGhB,aAAIT,CAAUzI,GAEV1H,KAAKqQ,MAAmB,SAAV3I,EACd1H,KAAK4Q,WAAalJ,EACb,KAAAmJ,aAAelB,EAAajI,IAAuC,EAO5E,iBAAI0I,GAEA,OAAOpQ,KAAK8Q,cAAA,CAGhB,iBAAIV,CAAc1I,GAET,KAAA6I,UAAY7I,EACjB1H,KAAK8Q,eAAiBpJ,CAAA,CAInBqJ,QAAAA,GAEH,MAAO,iCACY/Q,KAAKmQ,gCACInQ,KAAK0Q,8BAChB1Q,KAAKyQ,qBACHzQ,KAAKsQ,2BACDtQ,KAAKoQ,gBAAa,CAS7C,YAAcY,GAEJ,MAAA/C,EAAQ,IAAIiC,EAKX,OAHPjC,EAAM0C,WAAY,EAClB1C,EAAMoC,OAAQ,EAEPpC,CAAA,GA7MFiC,EAgNKe,UAAYf,EAAMc,QAhN7B,IAAME,EAANhB,C,oECxBP,IAAIiB,EAAQ,EAmKC,MAAAxG,EAAc,IAvJpB,MAoBH9H,WAAAA,CAAYuO,GANJ,KAAAC,aAA8CvR,OAAAwR,OAAO,MAQzDtR,KAAKuR,aAAe,CAAC,EAChB,KAAAH,eAAiBA,GAAkB,CAAC,EACzCpR,KAAKwR,kBAAmB,EASrBC,aAAAA,CAAcrE,EAAoBC,EAAqB/D,GAEpD,MAAAoI,EAAgB,IAAIC,EAAAA,EAAc,IACjC3R,KAAKoR,eAERtQ,MAAOsM,EACPrM,OAAQsM,EACRlE,WAAY,EACZG,YACAsI,oBAAoB,IAGxB,OAAO,IAAI7G,EAAAA,EAAQ,CACf7B,OAAQwI,EACRG,MAAO,eAAeV,KACzB,CAWEvG,iBAAAA,CAAkBkH,EAAoBC,GAC7C,IADkE5I,EAAA6I,UAAA3M,OAAA,QAAA4M,IAAAD,UAAA,GAAAA,UAAA,GAAa,EAAG1I,EAClF0I,UAAA3M,OAAA,EAAA2M,UAAA,QAAAC,EACQC,EAAWxI,KAAKW,KAAMyH,EAAa3I,EAAc,MACjDgJ,EAAYzI,KAAKW,KAAM0H,EAAc5I,EAAc,MAEvD+I,GAAWE,EAAAA,EAAAA,IAASF,GACpBC,GAAYC,EAAAA,EAAAA,IAASD,GAErB,MAAME,GAAOH,GAAY,KAAOC,GAAa,IAAM7I,EAAY,EAAI,GAE9DtJ,KAAKuR,aAAac,KAEd,KAAAd,aAAac,GAAO,IAG7B,IAAIvD,EAAU9O,KAAKuR,aAAac,GAAK5O,MAuB9B,OArBFqL,IAEDA,EAAU9O,KAAKyR,cAAcS,EAAUC,EAAW7I,IAGtDwF,EAAQ5F,OAAOU,YAAcT,EACrB2F,EAAA5F,OAAOpI,MAAQoR,EAAW/I,EAC1B2F,EAAA5F,OAAOnI,OAASoR,EAAYhJ,EACpC2F,EAAQ5F,OAAOkE,WAAa8E,EAC5BpD,EAAQ5F,OAAOmE,YAAc8E,EAG7BrD,EAAQ3B,MAAMrB,EAAI,EAClBgD,EAAQ3B,MAAMpB,EAAI,EAClB+C,EAAQ3B,MAAMrM,MAAQgR,EACtBhD,EAAQ3B,MAAMpM,OAASgR,EAEvBjD,EAAQwD,YAEH,KAAAjB,aAAavC,EAAQyD,KAAOF,EAE1BvD,CAAA,CASJ0D,kBAAAA,CAAmB1D,GAC1B,IAD4CxF,EAAA0I,UAAA3M,OAAA,QAAA4M,IAAAD,UAAA,IAAAA,UAAA,GAExC,MAAM9I,EAAS4F,EAAQ5F,OAEhB,OAAAlJ,KAAK4K,kBAAkBkE,EAAQhO,MAAOgO,EAAQ/N,OAAQmI,EAAOU,YAAaN,EAAS,CAOvFkC,aAAAA,CAAciH,GAEjB,MAAMJ,EAAMrS,KAAKqR,aAAaoB,EAAcF,KAE5CvS,KAAKuR,aAAac,GAAKtP,KAAK0P,EAAa,CAOtChO,KAAAA,CAAMiO,GAGT,GADAA,GAAsC,IAApBA,EAGH,UAAAxM,KAAKlG,KAAKuR,aACrB,CACU,MAAAoB,EAAW3S,KAAKuR,aAAarL,GAEnC,GAAIyM,EAEA,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAStN,OAAQuN,IAExBD,EAAAC,GAAGpR,SAAQ,EAE5B,CAIRxB,KAAKuR,aAAe,CAAC,G,iBC5Jb,SAAAsB,EAAoBC,EAAcC,EAAmB9L,GAE3D,MAAA+L,GAAUF,GAAQ,GAAM,KAAQ,IAEtCC,EAAI9L,MAAqB,IAAP6L,GAAe,IAAOE,EACxCD,EAAI9L,MAAe6L,GAAQ,EAAK,KAAQ,IAAOE,EAC/CD,EAAI9L,MAAe6L,GAAQ,GAAM,KAAQ,IAAOE,EAChDD,EAAI9L,KAAY+L,CACpB,C,gGCeO,MAAMC,EAoBTpQ,WAAAA,CAAYxB,EAA0B6R,GAP/B,KAAAjF,MAAeiD,EAAAA,EAAMF,QAGpB,KAAAmC,qBAAmErT,OAAAwR,OAAO,MAElF,KAAiB8B,wBAA0BpT,KAAKqT,kBAAkBxI,KAAK7K,MAInEA,KAAKqB,SAAWA,EAEhBrB,KAAKsT,SAAWJ,EAChBlT,KAAKsT,SAAS1T,OAEdI,KAAKqB,SAASkS,aAAaC,eAAexT,KAAM,uBAAsB,CAGnEyT,kBAAAA,CAAmBC,GAItB,MAAMC,EAAUD,EAASC,QAEnBC,IAAe5T,KAAKmT,qBAAqBO,EAASnB,KAElDsB,EAAa7T,KAAKqB,SAASyS,gBAAgBC,iBAAiBJ,GAElE,SAAIE,EAAWG,aAAeJ,IAAeC,EAAWG,YAMjD,CAGJC,aAAAA,CAAcP,EAAoBxQ,GAErC,MAAM2Q,EAAa7T,KAAKqB,SAASyS,gBAAgBC,iBAAiBL,EAASC,SAKvED,EAASQ,eAETlU,KAAKmU,SAAST,GAGdG,EAAWG,YAEN,KAAAI,cAAcV,EAAUxQ,IAI7BlD,KAAKqB,SAAS8B,YAAYC,MAAMC,MAAMH,GACtCA,EAAef,IAAIuR,GACvB,CAGGW,gBAAAA,CAAiBX,GAEpB,MAAMY,EAAUtU,KAAKmT,qBAAqBO,EAASnB,KAEnD,GAAI+B,EAEA,IAAK,IAAIpO,EAAI,EAAGA,EAAIoO,EAAQjP,OAAQa,IACpC,CACU,MAAA9C,EAAQkR,EAAQpO,GAEhB9C,EAAAmR,SAASC,cAAcpR,EAAK,CAE1C,CAGGiQ,iBAAAA,CAAkBK,GAEjB1T,KAAKmT,qBAAqBO,EAASnB,MAE9B,KAAAkC,0BAA0Bf,EAASnB,KAGnCmB,EAAAgB,IAAI,YAAa1U,KAAKoT,wBAAuB,CAGnDxP,OAAAA,CAAQ8P,GAEX,IAAKA,EAASiB,aAAc,OAE5B,MAAMtT,EAAWrB,KAAKqB,SAChBsS,EAAUD,EAASC,QAIzB,IAHsBtS,EAASyS,gBAGZc,cAAcjB,GAASW,QAAQjP,OAChD,OAEF,MAAM2I,EAAS2F,EAAQkB,cAAgB7U,KAAKsT,SAAStF,OAEhD,KAAAC,MAAMkC,UAAYuD,EAASoB,eAE1B,MAAAC,EAAgB/G,EAAOgH,UAAUD,cAAcrI,SAErDqI,EAAcE,iBAAmBvB,EAAS1N,eAC5B+O,EAAAG,OAAS7T,EAAS8T,aAAezB,EAASyB,cAExDtC,EAAAA,EAAAA,GACIa,EAAS0B,gBACTL,EAAcM,OACd,GAGC,KAAA/B,SAAS1P,QAAQ5D,KAAM0T,EAAQ,CAGhCS,QAAAA,CAAST,GAEb,MAAME,IAAe5T,KAAKmT,qBAAqBO,EAASnB,KAElDsB,EAAa7T,KAAKqB,SAASyS,gBAAgBC,iBAAiBL,EAASC,SAIvEC,GAEK,KAAAa,0BAA0Bf,EAASnB,KAGxCsB,EAAWG,aAEXhU,KAAKsV,0BAA0B5B,GAGnCA,EAAS6B,QAAU1B,EAAWG,WAAA,CAG1BI,aAAAA,CAAcV,EAAoBxQ,GAEhC,MAAAsS,EAAYxV,KAAKqB,SAAS8B,YAAYC,MAEtCkR,EAAUtU,KAAKyV,yBAAyB/B,GAE9C,IAAK,IAAIxN,EAAI,EAAGA,EAAIoO,EAAQjP,OAAQa,IACpC,CACU,MAAA9C,EAAQkR,EAAQpO,GAEZsP,EAAAE,WAAWtS,EAAOF,EAAc,CAC9C,CAGIuS,wBAAAA,CAAyB/B,GAE7B,OAAO1T,KAAKmT,qBAAqBO,EAASnB,MAAQvS,KAAKsV,0BAA0B5B,EAAQ,CAGrF4B,yBAAAA,CAA0B5B,GAE9B,MAAMC,EAAUD,EAASC,QAEnBE,EAAiC7T,KAAKqB,SAASyS,gBAAgBc,cAAcjB,GAE7EgC,EAAe3V,KAAKqB,SAAS8T,aAAezB,EAASyB,aAErDb,EAAUT,EAAWS,QAAQsB,KAAKxS,IAE9B,MAAAyS,EAAaC,EAAAA,EAAQrV,IAAIsV,EAAAA,GAQxB,OANP3S,EAAMiD,OAAOwP,GAEbA,EAAWlN,WAAa+K,EAExBmC,EAAWF,YAAcA,EAElBE,CAAA,IAWJ,YARyC,IAA5C7V,KAAKmT,qBAAqBO,EAASnB,MAG1BmB,EAAAsC,GAAG,YAAahW,KAAKoT,yBAG7B,KAAAD,qBAAqBO,EAASnB,KAAO+B,EAEnCA,CAAA,CAGHG,yBAAAA,CAA0BwB,GAE9BjW,KAAKmT,qBAAqB8C,GAAaC,SAAS9S,IAE5C0S,EAAAA,EAAQtP,OAAOpD,EAAkB,IAGhC,KAAA+P,qBAAqB8C,GAAe,KAGtCzU,OAAAA,GAEHxB,KAAKqB,SAAW,KAEhBrB,KAAKsT,SAAS9R,UACdxB,KAAKsT,SAAW,KAChBtT,KAAKiO,MAAQ,KAEF,UAAA/H,KAAKlG,KAAKmT,qBAEjBnT,KAAKyU,0BAA0BvO,GAGnClG,KAAKmT,qBAAuB,MA9NvBF,EAGKxR,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcsC,WACdtC,EAAAA,GAAcuC,YACdvC,EAAAA,GAAcwC,aAElBC,KAAM,YCrCdxB,EAAAA,GAAWR,IAAI8Q,GACftQ,EAAAA,GAAWR,IAAIgU,EAAAA,G,oGCgCR,MAAMC,EA6BTvT,WAAAA,CAAYxB,EAAoB6R,GAjBzB,KAAA6B,cAAgB,IAAIvN,EAAAA,EAAa,CACpCyN,iBAAkB,CAAEvN,MAAO,IAAIrD,EAAAA,EAAUN,KAAM,eAC/CsR,OAAQ,CAAE3N,MAAO,IAAIZ,aAAa,CAAC,EAAG,EAAG,EAAG,IAAK/C,KAAM,aACvDmR,OAAQ,CAAExN,MAAO,EAAG3D,KAAM,SAGvB,KAAAsS,uBAAyB,IAAIpO,EAAAA,EAAU,CAC1C,EAAGjI,KAAK+U,gBAKJ,KAAAuB,cAAiDxW,OAAAwR,OAAO,MACxD,KAAAiF,sBAA8DzW,OAAAwR,OAAO,MAE7E,KAAiB8B,wBAA0BpT,KAAKqT,kBAAkBxI,KAAK7K,MAInEA,KAAKqB,SAAWA,EAChBrB,KAAKsT,SAAWJ,EAEhBlT,KAAKsT,SAAS1T,OAELyB,EAAAkS,aAAaC,eAAexT,KAAM,yBAClCqB,EAAAkS,aAAaC,eAAexT,KAAM,gBAAe,CAGvDyT,kBAAAA,CAAmB+C,GAEhB,MAAAC,EAAWzW,KAAK0W,aAAaF,GAE7B5C,EAAa6C,EAASlB,QAEtBoB,EAAYH,EAAKjB,QAIvB,GAFAkB,EAASlB,QAAUoB,EAEf/C,IAAe+C,EAER,YAEFA,EACT,CACI,MAAM5I,EAAWyI,EAAKI,UAGlB,GAAA7I,EAAS8I,QAAQxR,SAAWoR,EAASK,WAC9B/I,EAASgJ,UAAU1R,SAAWoR,EAASO,WAKvC,OAHEP,EAAAK,UAAY/I,EAAS8I,QAAQxR,OAC7BoR,EAAAO,WAAajJ,EAASgJ,UAAU1R,QAElC,EAGL,MAAA4R,EAAgBjX,KAAKkX,kBAAkBV,GAEvC1H,EAAU0H,EAAK1H,QAErB,GAAImI,EAAcnI,QAAQF,UAAYE,EAAQF,SAEtCqI,EAAcnI,QAAQF,UAAYE,EAAQF,QAE1C,OAAQqI,EAAc1C,SAAS4C,sBAAsBF,EAAenI,EAE5E,CAGG,SAGJmF,aAAAA,CAAcuC,EAAYtT,GAEvB,MAAAkU,EAAUpX,KAAKqB,SAAS8B,YAAYC,OAEpC,QAAEmS,GAAYvV,KAAK0W,aAAaF,GAEtC,GAAIjB,EACJ,CACU,MAAA8B,EAAmBrX,KAAKkX,kBAAkBV,GAEhDa,EAAiBvI,QAAU0H,EAAKc,SAChCD,EAAiBtJ,SAAWyI,EAAKI,UAEzBQ,EAAA1B,WAAW2B,EAAkBnU,EAAc,MAInDkU,EAAQ/T,MAAMH,GAEdA,EAAef,IAAIqU,EACvB,CAGGnC,gBAAAA,CAAiBmC,GAEpB,GAAIA,EAAKjB,QACT,CACI,MAAM8B,EAAmBrX,KAAKuW,sBAAsBC,EAAKjE,KAEzD8E,EAAiBvI,QAAU0H,EAAKc,SAChCD,EAAiBtJ,SAAWyI,EAAKI,UAEhBS,EAAA9C,SAASC,cAAc6C,EAAgB,CAC5D,CAGGhE,iBAAAA,CAAkBmD,GAEhB,KAAAF,cAAcE,EAAKjE,KAAO,KAE/B,MAAMgF,EAAUvX,KAAKuW,sBAAsBC,EAAKjE,KAE5CgF,IAEAzB,EAAAA,EAAQtP,OAAO+Q,GACV,KAAAhB,sBAAsBC,EAAKjE,KAAO,MAGtCiE,EAAA9B,IAAI,YAAa1U,KAAKoT,wBAAuB,CAG/CxP,OAAAA,CAAQ4S,GAEX,IAAKA,EAAK7B,aAAc,OAExB6B,EAAKvI,MAAMkC,WAAYqH,EAAAA,EAAAA,GAA0BhB,EAAK1B,eAAgB0B,EAAK1H,QAAQF,SAEnF,MAAMmG,EAAgB/U,KAAK+U,cAEbA,EAAArI,SAASuI,iBAAmBuB,EAAKxQ,eAC/C+O,EAAcrI,SAASwI,OAASlV,KAAKqB,SAAS8T,aAAeqB,EAAKrB,aAClEJ,EAAcvH,UAEdqF,EAAAA,EAAAA,GACI2D,EAAKpB,gBACLL,EAAcrI,SAAS2I,OACvB,GAGC,KAAA/B,SAAS1P,QAAQ5D,KAAMwW,EAAI,CAG5BE,YAAAA,CAAaF,GAEjB,OAAOxW,KAAKsW,cAAcE,EAAKjE,MAAQvS,KAAKyX,cAAcjB,EAAI,CAG1DiB,aAAAA,CAAcjB,GAUX,OARF,KAAAF,cAAcE,EAAKjE,KAAO,CAC3BgD,QAASiB,EAAKjB,QACduB,UAAWN,EAAKI,UAAUC,SAASxR,OACnC2R,WAAYR,EAAKI,UAAUG,WAAW1R,QAGrCmR,EAAAR,GAAG,YAAahW,KAAKoT,yBAEnBpT,KAAKsW,cAAcE,EAAKjE,IAAG,CAG9B2E,iBAAAA,CAAkBV,GAEtB,OAAOxW,KAAKuW,sBAAsBC,EAAKjE,MAAQvS,KAAK0X,mBAAmBlB,EAAI,CAGvEkB,kBAAAA,CAAmBlB,GAGjB,MAAAe,EAAyBzB,EAAAA,EAAQrV,IAAIkX,EAAAA,GASpC,OAPPJ,EAAQ5O,WAAa6N,EACrBe,EAAQzI,QAAU0H,EAAKc,SACvBC,EAAQK,UAAYpB,EAAKxQ,eACzBuR,EAAQ5B,YAAe3V,KAAKqB,SAAS8T,aAAeqB,EAAKrB,aAEpD,KAAAoB,sBAAsBC,EAAKjE,KAAOgF,EAEhCA,CAAA,CAGJ/V,OAAAA,GAEQ,UAAA0E,KAAKlG,KAAKuW,sBAEbvW,KAAKuW,sBAAsBrQ,IAE3B4P,EAAAA,EAAQtP,OAAOxG,KAAKuW,sBAAsBrQ,IAIlDlG,KAAKuW,sBAAwB,KAC7BvW,KAAKsW,cAAgB,KAErBtW,KAAK+U,cAAgB,KACrB/U,KAAKqW,uBAAyB,KAE9BrW,KAAKsT,SAAS9R,UACdxB,KAAKsT,SAAW,KAEhBtT,KAAKqB,SAAW,MArNX+U,EAGK3U,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcsC,WACdtC,EAAAA,GAAcuC,YACdvC,EAAAA,GAAcwC,aAElBC,KAAM,QC3CdxB,EAAAA,GAAWR,IAAIiU,E,iCCQR,MAAMuB,EAAN9U,WAAAA,GAEH,KAAOgV,YAAc,UACrB,KAAgBC,YAAa,EAK7B,KAAOC,YAAc,EACrB,KAAOC,gBAAkB,EAKzB,KAAOrC,YAAqB,EAG5B,KAAOpB,SAAoB,KAC3B,KAAO0D,OAAgB,KAKvB,KAAQC,aAAsB,EAC9B,KAAQC,wBAAiC,EAEzC,aAAIhI,GAAc,OAAOnQ,KAAK2I,WAAWmM,cAAA,CAElCsD,KAAAA,GAEHpY,KAAK2I,WAAa,KAClB3I,KAAK8O,QAAU,KACf9O,KAAKuU,SAAW,KAChBvU,KAAKiY,OAAS,KACdjY,KAAK+N,SAAW,KAChB/N,KAAKkY,aAAc,EACnBlY,KAAKmY,wBAAyB,EAGlC,OAAIE,GAEA,MAEMC,EAFWtY,KAAK+N,SAEIwK,UAAU,OAE9BF,EAAMC,EAAS5J,KAErB,IAAI8J,EAAiBH,EACf,MAAAI,EAAgBzY,KAAK8O,QAAQ2J,cAoB5B,OAlBFA,EAAcC,WAEfF,EAAiBxY,KAAK2Y,gBAElB3Y,KAAKmY,yBAA2BM,EAAcG,WAAa5Y,KAAKkY,cAAgBI,EAASM,cAEpFJ,GAAkBA,EAAenT,OAASgT,EAAIhT,UAE/CmT,EAAiBxY,KAAK2Y,gBAAkB,IAAI7R,aAAauR,EAAIhT,SAGjErF,KAAKmY,uBAAyBM,EAAcG,UAC5C5Y,KAAKkY,YAAcI,EAASM,UAEdH,EAAAI,YAAYR,EAAqBG,KAIhDA,CAAA,CAGX,aAAIzB,GAEA,OAAO/W,KAAK+N,SAASgJ,SAAA,CAGzB,WAAIF,GAEA,OAAO7W,KAAK+N,SAAS8I,OAAA,CAGzB,SAAIiC,GAEA,OAAO9Y,KAAK2I,WAAWyM,eAAA,CAG3B,kBAAIpP,GAEA,OAAOhG,KAAK2I,WAAW3C,cAAA,CAG3B,iBAAI+S,GAEO,OAAA/Y,KAAK+N,SAASgJ,UAAU1R,OAAS,EAG5C,aAAIyR,GAEO,OAAA9W,KAAK+N,SAAS8I,QAAQxR,MAAA,E,8EC/E9B,MAAM2T,EAAN,MAAMA,UAAqBtS,EAAAA,EAe9B7D,WAAAA,GAEI,IAAIhD,GAAUmS,UAAA3M,QAAA,OAAA4M,EAAAD,UAAA,KAAW,CAAC,EAEtBnS,aAAmBiH,gBAGnBmS,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,6DAGVrZ,EAAA,CACNkX,UAAWlX,EACXwY,IAAArG,UAAA3M,QAAA,OAAA4M,EAAAD,UAAA,GACA6E,QAAA7E,UAAA3M,QAAA,OAAA4M,EAAAD,UAAA,KAIRnS,EAAU,IAAKmZ,EAAaG,kBAAmBtZ,GAE/C,MAAMkX,EAAYlX,EAAQkX,WAAa,IAAIjQ,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IACxEuR,EAAMxY,EAAQwY,KAAO,IAAIvR,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC5D+P,EAAUhX,EAAQgX,SAAW,IAAI1P,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IAE7DiS,EAAcvZ,EAAQwZ,mBAuBtB,OACF1S,WAAY,CACRC,UAAW,CACPC,OAxBW,IAAIyS,EAAAA,EAAO,CAC9B5K,KAAMqI,EACNlF,MAAO,2BACPuH,cACAG,MAAOC,EAAAA,EAAYC,OAASD,EAAAA,EAAYE,WAqBhC3S,OAAQ,YACRC,OAAQ,EACRC,OAAQ,GAEZ0S,IAAK,CACD9S,OAvBK,IAAIyS,EAAAA,EAAO,CACxB5K,KAAM2J,EACNxG,MAAO,qBACPuH,cACAG,MAAOC,EAAAA,EAAYC,OAASD,EAAAA,EAAYE,WAoBhC3S,OAAQ,YACRC,OAAQ,EACRC,OAAQ,IAGhBC,YAtBgB,IAAIoS,EAAAA,EAAO,CAC3B5K,KAAMmI,EACNhF,MAAO,oBACPuH,cACAG,MAAOC,EAAAA,EAAYI,MAAQJ,EAAAA,EAAYE,WAmBvCvL,SAAUtO,EAAQsO,WAtE1B,KAAO0L,UAAuB,OA2E9B,aAAI9C,GAEO,OAAA/W,KAAK2G,WAAWC,UAAUC,OAAO6H,IAAA,CAG5C,aAAIqI,CAAUrP,GAEL,KAAAf,WAAWC,UAAUC,OAAO6H,KAAOhH,CAAA,CAI5C,OAAI2Q,GAEO,OAAArY,KAAK2G,WAAWgT,IAAI9S,OAAO6H,IAAA,CAGtC,OAAI2J,CAAI3Q,GAEC,KAAAf,WAAWgT,IAAI9S,OAAO6H,KAAOhH,CAAA,CAItC,WAAImP,GAEA,OAAO7W,KAAKkH,YAAYwH,IAAA,CAG5B,WAAImI,CAAQnP,GAER1H,KAAKkH,YAAYwH,KAAOhH,CAAA,GA/GnBsR,EAEKG,eAAsC,CAChDhL,SAAU,gBACVkL,oBAAoB,GAJrB,IAAMS,EAANd,C,+BC1BA,MAAMe,EAEFnW,OAAAA,CAAQoW,EAA6C/W,GAExD,MAAMgL,EAAQ+L,EAAqB/L,MAC7B5M,EAAW2Y,EAAqB3Y,SAChC2M,EAAS/K,EAAU+K,QAAUgM,EAAqBC,cAEjDjM,EAAAgH,UAAUkF,SAAWjX,EAAU6L,QAAQF,QACvCZ,EAAAgH,UAAUtI,SAAWsN,EAAqBjF,cAEjD,MAAMoF,EAAK9Y,EAAS8Y,GAEdtT,EAASmT,EAAqBI,WAAWnX,GAGtC5B,EAAA2M,OAAOnD,KAAKmD,GACZ3M,EAAA4M,MAAMhO,IAAIgO,GACnB5M,EAAS0M,SAASlD,KAAKhE,EAAOkH,SAAUC,EAAOqM,WAE/C,MACMC,EAAsB,IADXzT,EAAOkH,SAAS7G,YAAYwH,KAAK6L,kBAClBJ,EAAGK,eAAiBL,EAAGM,aAEpDN,EAAAO,aAAaP,EAAGQ,UAA+C,EAApC1X,EAAU2X,iBAAiBvV,OAAYiV,EAAQ,EAAC,E,uGCpBtE,SAAAO,EACZC,GAGJ,IAFIC,EAAA/I,UAAA3M,OAAA,QAAA4M,IAAAD,UAAA,GAAAA,UAAA,GAA8C,KAI9C,MAAMgJ,EAAsB,EAAPF,EAYjB,GAPYC,EAFZC,EAAe,MAEHD,GAAa,IAAI5T,YAAY6T,GAI7BD,GAAa,IAAIE,YAAYD,GAGzCD,EAAU1V,SAAW2V,EAErB,MAAM,IAAIE,MAAM,uCAAuCH,EAAU1V,uBAAuB2V,KAInF,QAAA9U,EAAI,EAAG0M,EAAI,EAAG1M,EAAI8U,EAAc9U,GAAK,EAAG0M,GAAK,EAExCmI,EAAA7U,EAAI,GAAK0M,EAAI,EACbmI,EAAA7U,EAAI,GAAK0M,EAAI,EACbmI,EAAA7U,EAAI,GAAK0M,EAAI,EACbmI,EAAA7U,EAAI,GAAK0M,EAAI,EACbmI,EAAA7U,EAAI,GAAK0M,EAAI,EACbmI,EAAA7U,EAAI,GAAK0M,EAAI,EAGpB,OAAAmI,CACX,CCxBA,SAASI,EACLC,EACAC,GAGA,MAAMC,EAA0B,GAEhCA,EAAcvY,KAAK,4IAUnB,IAAIkE,EAAS,EAEb,IAAK,MAAMf,KAAKkV,EAChB,CACU,MAAAG,EAAWH,EAAWlV,GAE5B,GAAImV,IAAYE,EAASF,QAAS,SAEpBC,EAAAvY,KAAK,oBAAoBkE,KAEzBqU,EAAAvY,KAAKwY,EAASC,MAI5BvU,IAFsBwU,EAAAA,EAAAA,GAA2BF,EAASxU,QAElCC,OAAS,EAGrCsU,EAAcvY,KAAK,uDAMnBuY,EAAcI,QAAQ,0BACHzU,YAGb,MAAA0U,EAAiBL,EAAcM,KAAK,MAG1C,OAAO,IAAIC,SAAS,KAAM,OAAQ,OAAQF,EAC9C,CCrCO,MAAMG,EA2BTjZ,WAAAA,CAAYhD,GARZ,KAAQkc,MAAQ,EAGhB,KAAiBC,6BAGZ,CAAC,EAKF,MAAMlB,EAAO9a,KAAK+b,MAAQlc,EAAQib,MAAQ,IAGpCM,EAAavb,EAAQub,WAG3B,IAAIa,EAAmB,EACnBC,EAAoB,EAExB,IAAK,MAAMhW,KAAKkV,EAChB,CACU,MAAAG,EAAWH,EAAWlV,GACtBiW,GAAgBV,EAAAA,EAAAA,GAA2BF,EAASxU,QAEtDwU,EAASF,QAGTa,GAAqBC,EAAcnV,OAKnCiV,GAAoBE,EAAcnV,MACtC,CAGJhH,KAAKoc,eAAiBF,EAAoB,EAC1Clc,KAAKqc,cAAgBJ,EAAmB,EAExCjc,KAAKsc,sBAAwB,IAAIC,EAAAA,EAAsB,EAAPzB,EAAWmB,GAC3Djc,KAAKwc,uBAAyB,IAAID,EAAAA,EAAsB,EAAPzB,EAAWoB,GAEvD,KAAAhV,YAAc2T,EAAsBC,GAInC,MAAA/M,EAAW,IAAIrH,EAAAA,EAErB,IAAI+V,EAAgB,EAChBC,EAAe,EAEd,KAAAC,cAAgB,IAAIrD,EAAAA,EAAO,CAC5B5K,KAAM,IAAI5H,aAAa,GACvB+K,MAAO,yBACPuH,aAAa,EACbG,MAAOC,EAAAA,EAAYC,OAASD,EAAAA,EAAYE,WAGvC,KAAAkD,eAAiB,IAAItD,EAAAA,EAAO,CAC7B5K,KAAM,IAAI5H,aAAa,GACvB+K,MAAO,0BACPuH,aAAa,EACbG,MAAOC,EAAAA,EAAYC,OAASD,EAAAA,EAAYE,WAG5C,IAAK,MAAMxT,KAAKkV,EAChB,CACU,MAAAG,EAAWH,EAAWlV,GACtBiW,GAAgBV,EAAAA,EAAAA,GAA2BF,EAASxU,QAEtDwU,EAASF,SAEAtN,EAAA8O,aAAatB,EAASuB,cAAe,CAC1CjW,OAAQ7G,KAAK4c,eACb5V,OAA8B,EAAtBhH,KAAKoc,eACbnV,OAAwB,EAAhBwV,EACR1V,OAAQwU,EAASxU,SAErB0V,GAAiBN,EAAcrB,OAItB/M,EAAA8O,aAAatB,EAASuB,cAAe,CAC1CjW,OAAQ7G,KAAK2c,cACb3V,OAA6B,EAArBhH,KAAKqc,cACbpV,OAAuB,EAAfyV,EACR3V,OAAQwU,EAASxU,SAErB2V,GAAgBP,EAAcrB,KAClC,CAGK/M,EAAAgP,SAAS/c,KAAKkH,aAEjB,MAAA8V,EAAiBhd,KAAKid,kBAAkB7B,GAE9Cpb,KAAKkd,eAAiBF,EAAeG,cACrCnd,KAAKod,cAAgBJ,EAAeK,aAEpCrd,KAAK+N,SAAWA,CAAA,CAGbkP,iBAAAA,CAAkB7B,GAEf,MAAA/I,EA6Dd,SAA4B+I,GAExB,MAAMkC,EAAmB,GAEzB,IAAK,MAAMjL,KAAO+I,EAClB,CACU,MAAAG,EAAWH,EAAW/I,GAE5BiL,EAAOva,KAAKsP,EAAKkJ,EAASC,KAAMD,EAASF,QAAU,IAAM,IAAG,CAGzD,OAAAiC,EAAO1B,KAAK,IACvB,CAzEoB2B,CAAmBnC,GAE3B,OAAApb,KAAKgc,6BAA6B3J,KAKtCrS,KAAKgc,6BAA6B3J,GAAOrS,KAAKwd,uBAAuBpC,IAH1Dpb,KAAKgc,6BAA6B3J,EAKD,CAGzCmL,sBAAAA,CAAuBpC,GAE1B,OD7JD,SAAwCA,GAEpC,OACH+B,cAAehC,EAAuBC,GAAY,GAClDiC,aAAclC,EAAuBC,GAAY,GAEzD,CCuJeqC,CAA+BrC,EAAU,CAG7C5N,MAAAA,CAAOkQ,EAAwBC,GAI9BD,EAAUrY,OAASrF,KAAK+b,QAET4B,GAAA,EAEV,KAAA5B,MAAQrS,KAAKuG,IAAIyN,EAAUrY,OAAsB,IAAbrF,KAAK+b,MAAe,GAExD,KAAAO,sBAAwB,IAAIC,EAAAA,EAAevc,KAAK+b,MAAQ/b,KAAKqc,cAAgB,EAAI,GACjF,KAAAG,uBAAyB,IAAID,EAAAA,EAAevc,KAAK+b,MAAQ/b,KAAKoc,eAAiB,EAAI,GACnF,KAAAlV,YAAc2T,EAAsB7a,KAAK+b,OAE9C/b,KAAK+N,SAAS7G,YAAY0W,gBACtB5d,KAAKkH,YAAalH,KAAKkH,YAAY2W,YAAY,IAGvD,MAAMrB,EAAyBxc,KAAKwc,uBAOpC,GALAxc,KAAKkd,eAAeQ,EAAWlB,EAAuBsB,YAAatB,EAAuBuB,YAE1F/d,KAAK4c,eAAegB,gBAChB5d,KAAKwc,uBAAuBsB,YAAaJ,EAAUrY,OAASrF,KAAKoc,eAAiB,GAAG,GAErFuB,EACJ,CACI,MAAMrB,EAAwBtc,KAAKsc,sBAEnCtc,KAAKod,cAAcM,EAAWpB,EAAsBwB,YAAaxB,EAAsByB,YAEvF/d,KAAK2c,cAAciB,gBACftB,EAAsBwB,YAAaJ,EAAUrY,OAASrF,KAAKqc,cAAgB,GAAG,EAAI,CAC1F,CAGG7a,OAAAA,GAEHxB,KAAK2c,cAAcnb,UACnBxB,KAAK4c,eAAepb,UACpBxB,KAAK+N,SAASvM,SAAQ,E,6wCCvMvB,MAAMwc,UAAuBC,EAAAA,EAEhCpb,WAAAA,GAkBU,OACFwX,UAjBc6D,EAAAA,EAAUC,KAAK,CAC7B/O,O,+7BACAgP,S,kLAgBAC,WAbeC,EAAAA,EAAWH,KAAK,CAC/BC,SAAU,CACNlV,OAAQqV,EACRC,WAAY,gBAEhBpP,OAAQ,CACJlG,OAAQqV,EACRC,WAAY,gBAOhBxJ,UAAW,CAEPkF,SAAUnP,EAAAA,EAAQ0T,MAAMvV,OAExBwV,SAAU,IAAIC,EAAAA,EAAa,IAE3BjS,SAAU,CACNkS,mBAAoB,CAAElX,MAAO,IAAIrD,EAAAA,EAAUN,KAAM,eACjDsR,OAAQ,CAAE3N,MAAO,IAAImX,EAAAA,EAAM,UAAW9a,KAAM,aAC5CmR,OAAQ,CAAExN,MAAO,EAAG3D,KAAM,OAC1B+a,YAAa,CAAEpX,MAAO,CAAC,EAAG,GAAI3D,KAAM,gBAG/C,ECvBF,MAAMgb,EAwBTlc,WAAAA,CAAYxB,EAAoB6R,GAlBhB,KAAAjF,MAAQiD,EAAAA,EAAMF,QAGtB,KAAAgO,eAAwDlf,OAAAwR,OAAO,MAEvE,KAAiB8B,wBAA0BpT,KAAKqT,kBAAkBxI,KAAK7K,MAEvD,KAAA+U,cAAgB,IAAIvN,EAAAA,EAAa,CAC7CoX,mBAAoB,CAAElX,MAAO,IAAIrD,EAAAA,EAAUN,KAAM,eACjDsR,OAAQ,CAAE3N,MAAO,IAAIZ,aAAa,GAAI/C,KAAM,aAC5CmR,OAAQ,CAAExN,MAAO,EAAG3D,KAAM,OAC1B+a,YAAa,CAAEpX,MAAO,CAAC,EAAG,GAAI3D,KAAM,eASpC/D,KAAKqB,SAAWA,EAEhBrB,KAAKkT,QAAUA,EAEV,KAAA+G,cAAgB,IAAI+D,EAEpB,KAAA/P,MAAQiD,EAAAA,EAAMF,OAAM,CAGtByC,kBAAAA,CAAmBwL,GAGf,SAGJhL,aAAAA,CAActL,EAA+BzF,GAEhDlD,KAAKqB,SAAS8B,YAAYC,MAAMC,MAAMH,GACtCA,EAAef,IAAIwG,EAAU,CAG1ByR,UAAAA,CAAWzR,GAEd,OAAO3I,KAAKgf,eAAerW,EAAW4J,MAAQvS,KAAKkf,YAAYvW,EAAU,CAGrEuW,WAAAA,CAAYvW,GAST,OAPP3I,KAAKgf,eAAerW,EAAW4J,KAAO,IAAIuJ,EAAe,CACrDhB,KAAMnS,EAAWiS,iBAAiBvV,OAClC+V,WAAYzS,EAAWwW,cAGhBxW,EAAAqN,GAAG,YAAahW,KAAKoT,yBAEzBpT,KAAKgf,eAAerW,EAAW4J,IAAG,CAGtC8B,gBAAAA,CAAiB4K,GACxB,CAKO5L,iBAAAA,CAAkB1K,GAEN3I,KAAKgf,eAAerW,EAAW4J,KAEvC/Q,UAEF,KAAAwd,eAAerW,EAAW4J,KAAO,KAE3B5J,EAAA+L,IAAI,YAAa1U,KAAKoT,wBAAuB,CAGrDxP,OAAAA,CAAQX,GAEX,MAAMgD,EAAWhD,EAAU2X,iBAEvB,GAAoB,IAApB3U,EAASZ,OAET,OAGJ,MAAMhE,EAAWrB,KAAKqB,SAChBwF,EAAS7G,KAAKoa,WAAWnX,GAE/BA,EAAU6L,UAAV7L,EAAU6L,QAAY7I,EAAS,GAAG6I,SAElC,MAAMb,EAAQjO,KAAKiO,MAEZpH,EAAA2G,OAAOvH,EAAUhD,EAAUmc,gBAClCnc,EAAUmc,gBAAiB,EAE3BnR,EAAMkC,WAAYqH,EAAAA,EAAAA,GAA0BvU,EAAUkN,UAAWlN,EAAU6L,QAAQF,SAE7E,MAAAlC,EAAW1M,KAAK+U,cAAcrI,SAE9B2S,EAAuB3S,EAASkS,mBAE5B3b,EAAA+B,eAAeqB,OAAOgZ,GAEhCA,EAAqBxQ,QAAQxN,EAASyJ,eAAewU,kBAAkBC,kBAE9D7S,EAAAoS,YAAczd,EAASyJ,eAAewU,kBAAkBnW,WACxDuD,EAAAwI,OAAS7T,EAAS8T,aAAelS,EAAUkS,cAEpDtC,EAAAA,EAAAA,GACI5P,EAAUmS,gBACV1I,EAAS2I,OACT,GAGC,KAAAnC,QAAQtP,QAAQ5D,KAAMiD,EAAS,CAIjCzB,OAAAA,GAECxB,KAAKia,gBAELja,KAAKia,cAAczY,UACnBxB,KAAKia,cAAgB,KACzB,ECnJD,MAAMuF,UAAgCT,EAUzClc,WAAAA,CAAYxB,GAEF,MAAAA,EAAU,IAAI0Y,EAA4B,EAZ3CyF,EAGK/d,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcsC,YAElBG,KAAM,YCTP,MAAMsb,EAEF7b,OAAAA,CAAQoW,EAA6C/W,GAExD,MAAM5B,EAAW2Y,EAAqB3Y,SAEhC2M,EAAS/K,EAAU+K,QAAUgM,EAAqBC,cAEjDjM,EAAAJ,OAAO,GAAKvM,EAAS8B,YAAYsK,aAAaiS,oBAAoB1F,EAAqBjF,eAAe,GAE7G/G,EAAOJ,OAAO,GAAKvM,EAASyN,QAAQ6Q,oBAAoB1c,EAAU6L,SAElE,MAAMb,EAAQ+L,EAAqB/L,MAE7BpH,EAASmT,EAAqBI,WAAWnX,GAE/C5B,EAASwM,QAAQC,KAAK,CAClBC,SAAUlH,EAAOkH,SACjBC,OAAQ/K,EAAU+K,QAAUgM,EAAqBC,cACjDhM,QACA6M,KAA0C,EAApC7X,EAAU2X,iBAAiBvV,QACpC,ECnBF,MAAMua,UAAiCb,EAU1Clc,WAAAA,CAAYxB,GAEF,MAAAA,EAAU,IAAIoe,EAA6B,EAZ5CG,EAGKne,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcuC,aAElBE,KAAM,YCNdxB,EAAAA,GAAWR,IAAIqd,GACf7c,EAAAA,GAAWR,IAAIyd,E,sEC0BR,MAAMC,EAAN,MAAMA,UAAsB/F,EAAAA,EAwB/BjX,WAAAA,GAEIid,MAAM,CAAC,GAEP,IAAIjgB,GAAUmS,UAAA3M,QAAA,OAAA4M,EAAAD,UAAA,KAAW,CAAC,EAEH,kBAAZnS,KAIPoZ,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,gGAGVrZ,EAAA,CACNiB,MAAOjB,EACPkB,OAAAiR,UAAA3M,QAAA,OAAA4M,EAAAD,UAAA,GACA+N,UAAA/N,UAAA3M,QAAA,OAAA4M,EAAAD,UAAA,GACAgO,UAAAhO,UAAA3M,QAAA,OAAA4M,EAAAD,UAAA,KAIRhS,KAAKigB,MAAMpgB,EAAO,CAOfogB,KAAAA,CAAMpgB,GAETA,EAAU,IAAKggB,EAAc1G,kBAAmBtZ,GAE3C,KAAAkgB,UAAY/f,KAAK+f,WAAalgB,EAAQkgB,UACtC,KAAAC,UAAYhgB,KAAKggB,WAAangB,EAAQmgB,UAEtC,KAAAlf,MAAQd,KAAKc,OAASjB,EAAQiB,MAC9B,KAAAC,OAASf,KAAKe,QAAUlB,EAAQkB,OAE/B,MAAAmf,EAAQlgB,KAAK+f,UAAY/f,KAAKggB,UAC9BG,EAAQ,GACR9H,EAAM,GACNxB,EAAU,GAEVkJ,EAAY/f,KAAK+f,UAAY,EAC7BC,EAAYhgB,KAAKggB,UAAY,EAE7BI,EAASpgB,KAAKc,MAASif,EACvBM,EAASrgB,KAAKe,OAAUif,EAE9B,IAAK,IAAI9Z,EAAI,EAAGA,EAAIga,EAAOha,IAC3B,CACU,MAAA4F,EAAK5F,EAAIlG,KAAK+f,UACdhU,EAAM7F,EAAIlG,KAAK+f,UAAa,EAElCI,EAAMpd,KAAK+I,EAAIsU,EAAOrU,EAAIsU,GAC1BhI,EAAItV,KAAK+I,EAAIiU,EAAWhU,EAAIiU,EAAS,CAGzC,MAAMM,EAAWP,EAAYC,EAE7B,IAAK,IAAI9Z,EAAI,EAAGA,EAAIoa,EAAUpa,IAC9B,CACI,MAAMqa,EAAOra,EAAI6Z,EACXS,EAAQta,EAAI6Z,EAAa,EAEzBrY,EAAS8Y,EAAOxgB,KAAK+f,UAAaQ,EAClCE,EAAUD,EAAOxgB,KAAK+f,UAAaQ,EAAO,EAC1CG,GAAWF,EAAO,GAAKxgB,KAAK+f,UAAaQ,EACzCI,GAAWH,EAAO,GAAKxgB,KAAK+f,UAAaQ,EAAO,EAE9C1J,EAAA9T,KAAK2E,EAAO+Y,EAAQC,EACxBD,EAAQE,EAAQD,EAAM,CAG9B1gB,KAAK4gB,QAAQ,GAAGlS,KAAO,IAAI5H,aAAaqZ,GACxCngB,KAAK4gB,QAAQ,GAAGlS,KAAO,IAAI5H,aAAauR,GACxCrY,KAAKkH,YAAYwH,KAAO,IAAIvH,YAAY0P,GAGnC,KAAA+J,QAAQ,GAAGpT,SACX,KAAAoT,QAAQ,GAAGpT,SAChBxN,KAAKkH,YAAYsG,QAAO,GAzGnBqS,EAEK1G,eAA6D,CACvErY,MAAO,IACPC,OAAQ,IACRgf,UAAW,GACXC,UAAW,IANZ,IAAMa,EAANhB,ECHA,MAAMiB,EAAN,MAAMA,UAA0BD,EA+BnChe,WAAAA,GACA,IADYhD,EAAoCmS,UAAA3M,OAAA,QAAA4M,IAAAD,UAAA,GAAAA,UAAA,MAE5CnS,EAAU,IAAKihB,EAAkB3H,kBAAmBtZ,GAE9C,OACFiB,MAAOjB,EAAQiB,MACfC,OAAQlB,EAAQkB,OAChBgf,UAAW,EACXC,UAAW,IAGfhgB,KAAKwN,OAAO3N,EAAO,CAOhB2N,MAAAA,CAAO3N,GAEL,KAAAiB,MAAQjB,EAAQiB,OAASd,KAAKc,MAC9B,KAAAC,OAASlB,EAAQkB,QAAUf,KAAKe,OAChC,KAAAggB,eAAiBlhB,EAAQmhB,eAAiBhhB,KAAK+gB,eAC/C,KAAAE,gBAAkBphB,EAAQqhB,gBAAkBlhB,KAAKihB,gBACjD,KAAAE,WAAathB,EAAQuhB,WAAaphB,KAAKmhB,WACvC,KAAAE,YAAcxhB,EAAQyhB,YAActhB,KAAKqhB,YACzC,KAAAE,WAAa1hB,EAAQ2hB,WAAaxhB,KAAKuhB,WACvC,KAAAE,cAAgB5hB,EAAQ6hB,cAAgB1hB,KAAKyhB,cAElDzhB,KAAKsS,YACLtS,KAAK2hB,iBAAgB,CAIlBA,eAAAA,GAEH,MAAM5K,EAAY/W,KAAK+W,UAEjB6K,EAAI5hB,KAAKmhB,WAAanhB,KAAKqhB,YAC3BQ,EAAS7hB,KAAKc,MAAQ8gB,EAAI,EAAM5hB,KAAKc,MAAQ8gB,EAE7CE,EAAI9hB,KAAKuhB,WAAavhB,KAAKyhB,cAC3BM,EAAS/hB,KAAKe,OAAS+gB,EAAI,EAAM9hB,KAAKe,OAAS+gB,EAE/C7X,EAAQP,KAAKC,IAAIkY,EAAQE,GAE/BhL,EAAU,GAAKA,EAAU,IAAMA,EAAU,IAAMA,EAAU,IAAM/W,KAAKuhB,WAAatX,EACjF8M,EAAU,IAAMA,EAAU,IAAMA,EAAU,IAAMA,EAAU,IAAM/W,KAAKe,OAAUf,KAAKyhB,cAAgBxX,EAC1F8M,EAAA,IAAMA,EAAU,IAAMA,EAAU,IAAMA,EAAU,IAAM/W,KAAKe,OAErEgW,EAAU,GAAKA,EAAU,IAAMA,EAAU,IAAMA,EAAU,IAAM/W,KAAKmhB,WAAalX,EACjF8M,EAAU,GAAKA,EAAU,IAAMA,EAAU,IAAMA,EAAU,IAAM/W,KAAKc,MAASd,KAAKqhB,YAAcpX,EACtF8M,EAAA,GAAKA,EAAU,IAAMA,EAAU,IAAMA,EAAU,IAAM/W,KAAKc,MAE/D,KAAAyX,UAAU,aAAa/K,QAAO,CAIhC8E,SAAAA,GAEH,MAAM+F,EAAMrY,KAAKqY,IAEbA,EAAA,GAAKA,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAM,EAClCA,EAAA,GAAKA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAK,EAEhCA,EAAA,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EACnCA,EAAA,IAAMA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EAElC,MAAA2J,EAAO,EAAMhiB,KAAK+gB,eAClBkB,EAAO,EAAMjiB,KAAKihB,gBAExB5I,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM2J,EAAOhiB,KAAKmhB,WACnD9I,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM4J,EAAOjiB,KAAKuhB,WAEnDlJ,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EAAK2J,EAAOhiB,KAAKqhB,YACxDhJ,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EAAK4J,EAAOjiB,KAAKyhB,cAEpD,KAAAlJ,UAAU,OAAO/K,QAAO,GA5GxBsT,EAGK3H,eAA2C,CAErDrY,MAAO,IAEPC,OAAQ,IAERqgB,UAAW,GAEXI,UAAW,GAEXF,WAAY,GAEZI,aAAc,GAGdV,cAAe,IAEfE,eAAgB,KApBjB,IAAMgB,EAANpB,ECnBA,MAAMqB,EAgBTtf,WAAAA,CAAYxB,GAHK,KAAA+gB,eAAuDtiB,OAAAwR,OAAO,MAC/E,KAAiB8B,wBAA0BpT,KAAKqT,kBAAkBxI,KAAK7K,MAInEA,KAAK8C,UAAYzB,EACjBrB,KAAK8C,UAAUyQ,aAAaC,eAAexT,KAAM,iBAAgB,CAG9DiU,aAAAA,CAAcxF,EAAyBvL,GAEpC,MAAAmf,EAAYriB,KAAKsiB,cAAc7T,GAEjCA,EAAOyF,eAAoB,KAAAqO,uBAAuB9T,EAAQ4T,GAE9DriB,KAAK8C,UAAUK,YAAYC,MAAMsS,WAAW2M,EAAWnf,EAAc,CAGlEmR,gBAAAA,CAAiB5F,GAEpB,MAAM4T,EAAYriB,KAAKoiB,eAAe3T,EAAO8D,KAEzC9D,EAAOyF,eAAoB,KAAAqO,uBAAuB9T,EAAQ4T,GAEpDA,EAAA9N,SAASC,cAAc6N,EAAS,CAGvC5O,kBAAAA,CAAmBhF,GAEtB,MAAMK,EAAUL,EAAO6I,SACjB+K,EAAYriB,KAAKsiB,cAAc7T,GAErC,OAAI4T,EAAUvT,QAAQF,UAAYE,EAAQF,UAE9ByT,EAAU9N,SAAS4C,sBAAsBkL,EAAWvT,EAGzD,CAGJuE,iBAAAA,CAAkB5E,GAErB,MAAMwI,EAAgBjX,KAAKoiB,eAAe3T,EAAO8D,KAGzCuD,EAAAA,EAAAtP,OAAOyQ,EAAclJ,UAC7B+H,EAAAA,EAAQtP,OAAOyQ,GAEV,KAAAmL,eAAe3T,EAAO8D,KAAO,KAE3B9D,EAAAiG,IAAI,YAAa1U,KAAKoT,wBAAuB,CAGhDmP,sBAAAA,CAAuB9T,EAAyB+T,GAEnDA,EAAgBzU,SACZP,OAAOiB,GAGZ+T,EAAgB1T,QAAUL,EAAO6I,QAAA,CAG7BgL,aAAAA,CAAc7T,GAElB,OAAOzO,KAAKoiB,eAAe3T,EAAO8D,MAAQvS,KAAKyiB,eAAehU,EAAM,CAGhEgU,cAAAA,CAAehU,GAEb,MAAAwI,EAAgBnB,EAAAA,EAAQrV,IAAIkX,EAAAA,GAa3B,OAXOV,EAAAlJ,SAAW+H,EAAAA,EAAQrV,IAAIyhB,GACrCjL,EAActO,WAAa8F,EAC3BwI,EAAcW,UAAYnJ,EAAOzI,eACjCiR,EAAcnI,QAAUL,EAAO6I,SAC/BL,EAActB,YAAe3V,KAAK8C,UAAUqS,aAAe1G,EAAO0G,aAE7D,KAAAiN,eAAe3T,EAAO8D,KAAO0E,EAG3BxI,EAAAuH,GAAG,YAAahW,KAAKoT,yBAErB6D,CAAA,CAGJzV,OAAAA,GAEQ,UAAA0E,KAAKlG,KAAKoiB,eACrB,CAC0BpiB,KAAKoiB,eAAelc,GAE5B6H,SAASvM,SAAQ,CAGlCxB,KAAKoiB,eAA0B,KAC/BpiB,KAAK8C,UAAqB,MA5GtBqf,EAGK1gB,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcsC,WACdtC,EAAAA,GAAcuC,YACdvC,EAAAA,GAAcwC,aAElBC,KAAM,mBClBdxB,EAAAA,GAAWR,IAAIggB,E,6JCHR,MAAMO,EAAY,CACrBve,KAAM,aACNiL,OAAQ,CACJC,OAAkB,geAalBC,KAAgB,6LAOpB8O,SAAU,CACN/O,OAAkB,geAalBC,KAAgB,khBAoBXqT,EAAc,CACvBxe,KAAM,aACNiL,OAAQ,CACJC,OAAkB,2GAKlBC,KAAgB,iJAOpB8O,SAAU,CACN/O,OAAkB,0KAMlBC,KAAgB,mWChExB,IAAI+O,EACAhE,EAEG,MAAMuI,UAA2B3E,EAAAA,EAEpCpb,WAAAA,GAEIwb,IAAAA,GAAewE,EAAAA,EAAAA,GAA4B,CACvC1e,KAAM,uBACN2e,KAAM,CACF3T,EAAAA,GACAuT,EACAK,EAAAA,MAIR1I,IAAAA,GAAc2I,EAAAA,EAAAA,GAA2B,CACrC7e,KAAM,uBACN2e,KAAM,CACFpT,EAAAA,GACAiT,EACAM,EAAAA,MAIF,MAAAC,EAAiB,IAAI1b,EAAAA,EAAa,CACpC2b,UAAW,CAAEzb,MAAO,IAAIrD,EAAAA,EAAUN,KAAM,eACxCqf,YAAa,CAAE1b,MAAO,IAAIZ,aAAa,CAAC,EAAG,EAAG,EAAG,IAAK/C,KAAM,aAC5Dsf,aAAc,CAAE3b,MAAO,IAAIZ,aAAa,CAAC,EAAG,IAAK/C,KAAM,aACvDuf,kBAAmB,CAAE5b,MAAO,IAAIrD,EAAAA,EAAUN,KAAM,eAChDwf,YAAa,CAAE7b,MAAO,IAAIZ,aAAa,CAAC,IAAK,IAAK,GAAK,KAAO/C,KAAM,eAGlE,OACFsW,YACAgE,aACArJ,UAAW,CACPD,cAAe,IAAIvN,EAAAA,EAAa,CAC5ByN,iBAAkB,CAAEvN,MAAO,IAAIrD,EAAAA,EAAUN,KAAM,eAC/CsR,OAAQ,CAAE3N,MAAO,IAAIZ,aAAa,CAAC,EAAG,EAAG,EAAG,IAAK/C,KAAM,aACvDmR,OAAQ,CAAExN,MAAO,EAAG3D,KAAM,SAE9Bmf,iBACAhJ,SAAUnP,EAAAA,EAAQC,MAAM9B,OACxBwV,SAAU3T,EAAAA,EAAQC,MAAM9B,OAAOoC,QAEtC,CAGEkY,cAAAA,CACH1iB,EAAeC,EACf2H,EACA+a,EAAiBC,EACjB5U,GAGM,MAAAoU,EAAiBljB,KAAKgV,UAAUkO,eAEhCS,EAAe7U,EAAQhO,MACvB8iB,EAAgB9U,EAAQ/N,OACxB0X,EAAgB3J,EAAQ2J,cAExB6K,EAAoBJ,EAAexW,SAAS4W,kBAEhCA,EAAArjB,IACdyI,EAAOmb,EAAIF,EAAe7iB,EAC1B4H,EAAOob,EAAIH,EAAe5iB,EAC1B2H,EAAOqb,EAAIH,EAAgB9iB,EAC3B4H,EAAOsb,EAAIJ,EAAgB7iB,EAC3B2H,EAAOub,GAAKnjB,EACZ4H,EAAOwb,GAAKnjB,GAEhBuiB,EAAkBhd,SAEH4c,EAAAxW,SAASyW,UAAY1K,EAAc0L,SACnCjB,EAAAxW,SAAS0W,YAAc3K,EAAc2K,YACrCF,EAAAxW,SAAS2W,aAAe5K,EAAc4K,aACrDH,EAAexW,SAAS4W,kBAAoBA,EAC7BJ,EAAAxW,SAAS6W,YAAY,GAAKziB,EAC1BoiB,EAAAxW,SAAS6W,YAAY,GAAKxiB,EAC1BmiB,EAAAxW,SAAS6W,YAAY,GAAKE,EAC1BP,EAAAxW,SAAS6W,YAAY,GAAKG,EAErC5U,IAEK,KAAAkG,UAAUkF,SAAWpL,EAAQ5F,OAC7B,KAAA8L,UAAU0J,SAAW5P,EAAQ5F,OAAOoC,MAC7C,ECpGD,MAAM8Y,UAAqBtK,EAAAA,EAE9BjX,WAAAA,GAEU,OACFkU,UAAW,IAAIjQ,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAClDuR,IAAK,IAAIvR,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC5C+P,QAAS,IAAI1P,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,KAC5C,ECkBT,MAAMkd,EAAa,IAAID,EAEhB,MAAME,EAiBTzhB,WAAAA,CAAYxB,GAJZ,KAAiB6M,OAAgBgD,EAAAA,EAAMD,UACtB,KAAAsT,sBAA+DzkB,OAAAwR,OAAO,MACvF,KAAiB8B,wBAA0BpT,KAAKqT,kBAAkBxI,KAAK7K,MAInEA,KAAK8C,UAAYzB,EACjBrB,KAAK8C,UAAUyQ,aAAaC,eAAexT,KAAM,wBAAuB,CAGrEyT,kBAAAA,CAAmB9K,GAEhB,MAAA6b,EAAmBxkB,KAAKykB,qBAAqB9b,GAE7C+b,EAAaF,EAAiBG,SAEpC3kB,KAAK4kB,gBAAgBjc,GAErB,MAAMgc,EAAWH,EAAiBG,SAE9B,GAAAA,GAAYA,IAAaD,EAC7B,CACU,oBAAEzN,GAAkBuN,EAG1B,GAAIvN,GAAiBA,EAAcnI,QAAQF,UAAYjG,EAAWmG,QAAQF,QAEtE,OAAQqI,EAAc1C,SAAS4C,sBAAsBF,EAAetO,EAAWmG,QACnF,CAGJ,OAAQ4V,IAAeC,CAAA,CAQpB1Q,aAAAA,CAAc4Q,EAA4B3hB,GAEvC,MAAAkU,EAAUpX,KAAK8C,UAAUK,YAAYC,MAG3CpD,KAAK4kB,gBAAgBC,GAEf,MAAAL,EAAmBxkB,KAAKykB,qBAAqBI,IAE7C,SAAE9W,EAAU4W,SAAAA,GAAaH,EAE/B,GAAIG,EACJ,CACIH,EAAiBvN,gBAAjBuN,EAAiBvN,cAAkB,IAAIU,EAAAA,GAEvC,MAAMV,EAAgBuN,EAAiBvN,cAEnC4N,EAAa3Q,gBAEblU,KAAK8kB,qBAAqBD,GAE1B5N,EAAclJ,SAAWA,EACzBkJ,EAActO,WAAakc,EAC3B5N,EAAcW,UAAYiN,EAAa7e,eACvCiR,EAAcnI,QAAU+V,EAAavN,UAGzCL,EAActB,YAAe3V,KAAK8C,UAAUqS,aAAe0P,EAAa1P,aAEhEiC,EAAA1B,WAAWuB,EAAe/T,EAAc,MAIhDkU,EAAQ/T,MAAMH,GAEdshB,EAAiBxW,SAAjBwW,EAAiBxW,OAAW,IAAI4U,GAEhC5iB,KAAKqU,iBAAiBwQ,GAEtB3hB,EAAef,IAAI0iB,EACvB,CAGGjhB,OAAAA,CAAQihB,GAEX,MAAM,OAAE7W,GAAWhO,KAAKukB,sBAAsBM,EAAatS,KAE3DvE,EAAOJ,OAAO,GAAK5N,KAAK8C,UAAUgI,eAAeia,UAG3C,MAAAhQ,EAAgB/G,EAAOgH,UAAUD,cAAcrI,SAErDqI,EAAcE,iBAAmB4P,EAAa7e,eAC9C+O,EAAcG,OAASlV,KAAK8C,UAAUqS,aAAe0P,EAAa1P,cAElEtC,EAAAA,EAAAA,GACIgS,EAAazP,gBACbL,EAAcM,OACd,GAGJrV,KAAKkO,OAAOiC,WAAYqH,EAAAA,EAAAA,GAA0BqN,EAAa/P,eAAgB+P,EAAa/V,QAAQF,SAE/F,KAAA9L,UAAU+K,QAAQC,KAAK,CACxBC,SAAUsW,EACVrW,SACAC,MAAOjO,KAAKkO,QACf,CAGEmG,gBAAAA,CAAiBwQ,GAEd,MAAAL,EAAmBxkB,KAAKykB,qBAAqBI,IAE7C,SAAEF,GAAaH,EAErB,GAAIG,EACJ,CACU,oBAAE1N,GAAkBuN,EAEtBK,EAAa3Q,eAAelU,KAAK8kB,qBAAqBD,GAE5C5N,EAAA1C,SAASC,cAAcyC,EAAa,MACtD,GACS4N,EAAa3Q,cACtB,CACU,aAAElG,GAAWwW,EAGZxW,EAAAwV,eACHqB,EAAa/jB,MACb+jB,EAAa9jB,OACb8jB,EAAaG,eAAetc,OAC5Bmc,EAAa7V,OAAOlD,EACpB+Y,EAAa7V,OAAOjD,EACpB8Y,EAAa/V,QACjB,CACJ,CAGGuE,iBAAAA,CAAkBwR,GAEf,MAAAL,EAAmBxkB,KAAKykB,qBAAqBI,GAEnDL,EAAiBvN,cAAgB,KAEjCuN,EAAiBxW,QAAQxM,UAEpB,KAAA+iB,sBAAsBM,EAAatS,KAAO,KAElCsS,EAAAnQ,IAAI,YAAa1U,KAAKoT,wBAAuB,CAGtDqR,oBAAAA,CAAqB9b,GAEzB,OAAO3I,KAAKukB,sBAAsB5b,EAAW4J,MAAQvS,KAAKilB,sBAAsBtc,EAAU,CAGtFsc,qBAAAA,CAAsBJ,GAEpB,MAAA9W,EAAW,IAAI+L,EAAAA,EAAa,CAC9BjD,QAASwN,EAAWxN,QACpBE,UAAWsN,EAAWtN,UAAUmO,QAChC7M,IAAKgM,EAAWhM,IAAI6M,UAWjB,OARF,KAAAX,sBAAsBM,EAAatS,KAAO,CAC3CoS,UAAU,EACVhc,WAAYkc,EACZ9W,YAGS8W,EAAA7O,GAAG,YAAahW,KAAKoT,yBAE3BpT,KAAKukB,sBAAsBM,EAAatS,IAAG,CAG9CuS,oBAAAA,CAAqBD,GAEnB,MAAAM,EAAiBnlB,KAAKykB,qBAAqBI,IAE3C,SAAE9W,GAAaoX,EAEf7Z,EAAQuZ,EAAa/V,QAAQ5F,OAAOoC,MAEhB,WAAtBA,EAAM8Z,cAEN9Z,EAAM8Z,YAAc,SACpB9Z,EAAMkC,UCjOF,SAAOqX,EAA4BxM,GAE/C,MAAMvJ,EAAU+V,EAAa/V,QAEvBhO,EAAQgO,EAAQ3B,MAAMrM,MACtBC,EAAS+N,EAAQ3B,MAAMpM,OAE7B,IAAI0iB,EAAU,EACVC,EAAU,EAEVmB,EAAaQ,wBAEb5B,EAAUoB,EAAa7V,OAAOlD,EAC9B4X,EAAUmB,EAAa7V,OAAOjD,GAGlCsM,EAAI,GAAKA,EAAI,IAAMoL,EACnBpL,EAAI,GAAKA,EAAI,GAAK,EAAIoL,EACtBpL,EAAI,GAAKA,EAAI,IAAMqL,EACnBrL,EAAI,GAAKA,EAAI,GAAK,EAAIqL,EAEtB,MAAMjL,EAAgBpU,EAAAA,EAAO5B,OAEfgW,EAAA6M,SAAST,EAAaG,eAAetc,QAEnD+P,EAAcwL,IAAMY,EAAa/jB,MACjC2X,EAAcyL,IAAMW,EAAa9jB,OAEjC0X,EAAcnS,SAEdmS,EAAcxO,MAAM4a,EAAa/jB,MAAQA,EAAO+jB,EAAa9jB,OAASA,GChCnE,SAAqBwkB,EAAmBve,EAAgBC,EAAgByB,GAE3E,IAAI8c,EAAQ,EACN,MAAA1K,EAAOyK,EAAMlgB,QAAU2B,GAAU,GAEjC6c,EAAInb,EAAOmb,EACXC,EAAIpb,EAAOob,EACXC,EAAIrb,EAAOqb,EACXC,EAAItb,EAAOsb,EACXC,EAAKvb,EAAOub,GACZC,EAAKxb,EAAOwb,GAIlB,IAFUjd,GAAAD,EAEHwe,EAAQ1K,GACf,CACU,MAAAhP,EAAIyZ,EAAMte,GACV8E,EAAIwZ,EAAMte,EAAS,GAEzBse,EAAMte,GAAW4c,EAAI/X,EAAMiY,EAAIhY,EAAKkY,EACpCsB,EAAMte,EAAS,GAAM6c,EAAIhY,EAAMkY,EAAIjY,EAAKmY,EAE9Bjd,GAAAD,EAEVwe,GAAA,CAER,CDQgB3gB,CAAAwT,EAAK,EAAG,EAAGI,EAC3B,CDmMegN,CAAAZ,EAAc9W,EAASsK,KGvOtB,SAAawM,EAA4B9N,GAE/C,MAAA0M,EAAUoB,EAAa7V,OAAOlD,EAC9B4X,EAAUmB,EAAa7V,OAAOjD,EAEpCgL,EAAU,IAAM0M,EAAUoB,EAAa/jB,MACvCiW,EAAU,IAAM2M,EAAUmB,EAAa9jB,OACvCgW,EAAU,IAAM,EAAI0M,GAAWoB,EAAa/jB,MAC5CiW,EAAU,IAAM2M,EAAUmB,EAAa9jB,OACvCgW,EAAU,IAAM,EAAI0M,GAAWoB,EAAa/jB,MAC5CiW,EAAU,IAAM,EAAI2M,GAAWmB,EAAa9jB,OAC5CgW,EAAU,IAAM0M,EAAUoB,EAAa/jB,MACvCiW,EAAU,IAAM,EAAI2M,GAAWmB,EAAa9jB,MAChD,CH2NqB2kB,CAAAb,EAAc9W,EAASgJ,UAAS,CAG1CvV,OAAAA,GAEQ,UAAA0E,KAAKlG,KAAKukB,sBAEjBvkB,KAAKqT,kBAAkBrT,KAAKukB,sBAAsBre,GAAGyC,YAGxD3I,KAAKukB,sBAAiC,KACvCvkB,KAAK8C,UAAY,KAGb8hB,eAAAA,CAAgBC,GAEd,MAAAM,EAAiBnlB,KAAKykB,qBAAqBI,GAC3C/V,EAAU+V,EAAa/V,QAE7B,IAAI6W,GAAqB,EASzB,OAPI3lB,KAAK8C,UAAUiB,OAASqK,EAAAA,EAAaC,QAEfsX,EAAA3lB,KAAK8C,UAA4B6Q,QAAQiS,SAASC,mBAG5EV,EAAeR,SAAW7V,EAAQ2J,cAAcC,WAAaiN,GAAsB7W,EAAQ5F,OAAO4c,cAE3FX,EAAeR,QAAA,EAxOjBL,EAGK7iB,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcsC,WACdtC,EAAAA,GAAcuC,YACdvC,EAAAA,GAAcwC,aAElBC,KAAM,gBIpCdxB,EAAAA,GAAWR,IAAImiB,E,kCCQR,MAAMyB,EAANljB,WAAAA,GAEH,KAAOgV,YAAc,UAGrB,KAAgBkB,cAAgB,EAChC,KAAgBjC,UAAY,EAC5B,KAAgBgB,YAAa,EAQ7B,KAAOnC,YAAqB,EAI5B,KAAOqQ,gBAAkB,EACzB,KAAOzR,SAAoB,KAC3B,KAAO0D,OAAgB,KAEvB,aAAI9H,GAAc,OAAOnQ,KAAK2I,WAAWmM,cAAA,CACzC,SAAIgE,GAAU,OAAO9Y,KAAK2I,WAAWyM,eAAA,CAE9BgD,KAAAA,GAEHpY,KAAK2I,WAAa,KAClB3I,KAAK8O,QAAU,KACf9O,KAAKuU,SAAW,KAChBvU,KAAKiY,OAAS,KACdjY,KAAKwE,OAAS,M,iFCDf,MAAMyhB,UAAiBC,EAAAA,EAW1BrjB,WAAAA,CAAYhD,GAEJA,aAAmBsmB,EAAAA,IAETtmB,EAAA,CAAE8T,QAAS9T,IAGzB,MAAM,QAAE8T,EAASgC,YAAAA,KAAgByQ,GAASvmB,GAAW,CAAC,EAEhD,OACFgS,MAAO,cACJuU,IApBX,KAAyB9iB,aAAuB,WA6BxCtD,KAAKqmB,SANJ1S,IAEe3T,KAAKsmB,cAAgB,IAAIH,EAAAA,GAO7CnmB,KAAKqmB,SAASrQ,GAAG,SAAUhW,KAAKumB,aAAcvmB,MAE9CA,KAAKwmB,eAAgB,EACrBxmB,KAAK2V,YAAcA,IAAe,EAGtC,WAAIhC,CAAQA,GAEJA,IAAY3T,KAAKqmB,WAErBrmB,KAAKqmB,SAAS3R,IAAI,SAAU1U,KAAKumB,aAAcvmB,MAE/CA,KAAKqmB,SAAW1S,EAGhB3T,KAAKqmB,SAASrQ,GAAG,SAAUhW,KAAKumB,aAAcvmB,MAE9CA,KAAKumB,eAAa,CAGtB,WAAI5S,GAEA,OAAO3T,KAAKqmB,QAAA,CAOhB,UAAa7hB,GAET,OAAOxE,KAAKqmB,SAAS7hB,MAAA,CAOlB4B,SAAAA,CAAU5B,GAENA,EAAA4B,UAAUpG,KAAKqmB,SAAS7hB,OAAM,CAOzBiiB,aAAAA,CAAcC,GAEnB,OAAA1mB,KAAKqmB,SAASI,cAAcC,EAAK,CAkB5BllB,OAAAA,CAAQ3B,GAEhBG,KAAKsmB,gBAAkBzmB,EAElB,KAAAymB,cAAc9kB,QAAQ3B,IAEV,IAAZA,IAAoE,IAA/CA,GAAmC8T,SAExD,KAAA0S,SAAS7kB,QAAQ3B,GAGzBG,KAAKsmB,cAAyB,KAC/BtmB,KAAKqmB,SAAW,KAEhBvG,MAAMte,QAAQ3B,EAAO,CAGjB8mB,kBAAAA,CAAmBC,EAA+BC,GAI/C,OAFN7mB,KAAK2T,QAAgBiT,MAAWC,GAE1B7mB,IAAA,CAWJ8mB,YAAAA,GACP,QAAAC,EAAA/U,UAAA3M,OADuBwhB,EACvB,IAAAG,MAAAD,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IADuBJ,EACvBI,GAAAjV,UAAAiV,GACW,OAAAjnB,KAAK2mB,mBAAmB,eAAgBE,EAAI,CAUhDK,cAAAA,GACP,QAAAC,EAAAnV,UAAA3M,OADyBwhB,EACzB,IAAAG,MAAAG,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADyBP,EACzBO,GAAApV,UAAAoV,GACW,OAAApnB,KAAK2mB,mBAAmB,iBAAkBE,EAAI,CAalDQ,IAAAA,GACP,QAAAC,EAAAtV,UAAA3M,OADewhB,EACf,IAAAG,MAAAM,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADeV,EACfU,GAAAvV,UAAAuV,GACW,OAAAvnB,KAAK2mB,mBAAmB,OAAQE,EAAI,CASxCW,MAAAA,GACP,QAAAC,EAAAzV,UAAA3M,OADiBwhB,EACjB,IAAAG,MAAAS,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADiBb,EACjBa,GAAA1V,UAAA0V,GACW,OAAA1nB,KAAK2mB,mBAAmB,SAAUE,EAAI,CAoB1C/X,OAAAA,GACP,QAAA6Y,EAAA3V,UAAA3M,OADkBwhB,EAClB,IAAAG,MAAAW,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADkBf,EAClBe,GAAA5V,UAAA4V,GACW,OAAA5nB,KAAK2mB,mBAAmB,UAAWE,EAAI,CAO3CgB,SAAAA,GAEH,OAAO7nB,KAAK2mB,mBAAmB,YAAa,GAAE,CAO3CmB,GAAAA,GAEH,OAAO9nB,KAAK2mB,mBAAmB,MAAO,GAAE,CAerCoB,GAAAA,GACP,QAAAC,EAAAhW,UAAA3M,OADcwhB,EACd,IAAAG,MAAAgB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADcpB,EACdoB,GAAAjW,UAAAiW,GACW,OAAAjoB,KAAK2mB,mBAAmB,MAAOE,EAAI,CAavCqB,KAAAA,GACP,QAAAC,EAAAnW,UAAA3M,OADgBwhB,EAChB,IAAAG,MAAAmB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADgBvB,EAChBuB,GAAApW,UAAAoW,GACW,OAAApoB,KAAK2mB,mBAAmB,QAASE,EAAI,CAiBzCwB,QAAAA,GACP,QAAAC,EAAAtW,UAAA3M,OADmBwhB,EACnB,IAAAG,MAAAsB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADmB1B,EACnB0B,GAAAvW,UAAAuW,GACW,OAAAvoB,KAAK2mB,mBAAmB,WAAYE,EAAI,CAkB5C2B,aAAAA,GACP,QAAAC,EAAAzW,UAAA3M,OADwBwhB,EACxB,IAAAG,MAAAyB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADwB7B,EACxB6B,GAAA1W,UAAA0W,GACW,OAAA1oB,KAAK2mB,mBAAmB,gBAAiBE,EAAI,CAOjD8B,SAAAA,GAEH,OAAO3oB,KAAK2mB,mBAAmB,YAAa,GAAE,CAY3CiC,OAAAA,GACP,QAAAC,EAAA7W,UAAA3M,OADkBwhB,EAClB,IAAAG,MAAA6B,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADkBjC,EAClBiC,GAAA9W,UAAA8W,GACW,OAAA9oB,KAAK2mB,mBAAmB,UAAWE,EAAI,CAU3CkC,MAAAA,GACP,QAAAC,EAAAhX,UAAA3M,OADiBwhB,EACjB,IAAAG,MAAAgC,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADiBpC,EACjBoC,GAAAjX,UAAAiX,GACW,OAAAjpB,KAAK2mB,mBAAmB,SAAUE,EAAI,CAQ1CqC,IAAAA,GACP,QAAAC,EAAAnX,UAAA3M,OADewhB,EACf,IAAAG,MAAAmC,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADevC,EACfuC,GAAApX,UAAAoX,GACW,OAAAppB,KAAK2mB,mBAAmB,OAAQE,EAAI,CASxCwC,MAAAA,GACP,QAAAC,EAAAtX,UAAA3M,OADiBwhB,EACjB,IAAAG,MAAAsC,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADiB1C,EACjB0C,GAAAvX,UAAAuX,GACW,OAAAvpB,KAAK2mB,mBAAmB,SAAUE,EAAI,CAS1C2C,MAAAA,GACP,QAAAC,EAAAzX,UAAA3M,OADiBwhB,EACjB,IAAAG,MAAAyC,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADiB7C,EACjB6C,GAAA1X,UAAA0X,GACW,OAAA1pB,KAAK2mB,mBAAmB,SAAUE,EAAI,CAa1C8C,gBAAAA,GACP,QAAAC,EAAA5X,UAAA3M,OAD2BwhB,EAC3B,IAAAG,MAAA4C,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAD2BhD,EAC3BgD,GAAA7X,UAAA6X,GACW,OAAA7pB,KAAK2mB,mBAAmB,mBAAoBE,EAAI,CAWpDiD,IAAAA,GACP,QAAAC,EAAA/X,UAAA3M,OADewhB,EACf,IAAAG,MAAA+C,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADenD,EACfmD,GAAAhY,UAAAgY,GACW,OAAAhqB,KAAK2mB,mBAAmB,OAAQE,EAAI,CAcxCoD,SAAAA,GACP,QAAAC,EAAAlY,UAAA3M,OADoBwhB,EACpB,IAAAG,MAAAkD,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADoBtD,EACpBsD,GAAAnY,UAAAmY,GACW,OAAAnqB,KAAK2mB,mBAAmB,YAAaE,EAAI,CAY7CuD,IAAAA,GACP,QAAAC,EAAArY,UAAA3M,OADewhB,EACf,IAAAG,MAAAqD,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADezD,EACfyD,GAAAtY,UAAAsY,GACW,OAAAtqB,KAAK2mB,mBAAmB,OAAQE,EAAI,CAaxC0D,WAAAA,GACP,QAAAC,EAAAxY,UAAA3M,OADsBwhB,EACtB,IAAAG,MAAAwD,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADsB5D,EACtB4D,GAAAzY,UAAAyY,GACW,OAAAzqB,KAAK2mB,mBAAmB,cAAeE,EAAI,CAc/C6D,SAAAA,GACP,QAAAC,EAAA3Y,UAAA3M,OADoBwhB,EACpB,IAAAG,MAAA2D,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADoB/D,EACpB+D,GAAA5Y,UAAA4Y,GACW,OAAA5qB,KAAK2mB,mBAAmB,YAAaE,EAAI,CAgB7CgE,UAAAA,GACP,QAAAC,EAAA9Y,UAAA3M,OADqBwhB,EACrB,IAAAG,MAAA8D,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADqBlE,EACrBkE,GAAA/Y,UAAA+Y,GACW,OAAA/qB,KAAK2mB,mBAAmB,aAAcE,EAAI,CAY9CmE,UAAAA,GACP,QAAAC,EAAAjZ,UAAA3M,OADqBwhB,EACrB,IAAAG,MAAAiE,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADqBrE,EACrBqE,GAAAlZ,UAAAkZ,GACW,OAAAlrB,KAAK2mB,mBAAmB,aAAcE,EAAI,CAY9CsE,WAAAA,GACP,QAAAC,EAAApZ,UAAA3M,OADsBwhB,EACtB,IAAAG,MAAAoE,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADsBxE,EACtBwE,GAAArZ,UAAAqZ,GACW,OAAArrB,KAAK2mB,mBAAmB,cAAeE,EAAI,CAmB/CyE,IAAAA,GACP,QAAAC,EAAAvZ,UAAA3M,OADewhB,EACf,IAAAG,MAAAuE,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADe3E,EACf2E,GAAAxZ,UAAAwZ,GACW,OAAAxrB,KAAK2mB,mBAAmB,OAAQE,EAAI,CAQxC4E,GAAAA,GACP,QAAAC,EAAA1Z,UAAA3M,OADcwhB,EACd,IAAAG,MAAA0E,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADc9E,EACd8E,GAAA3Z,UAAA2Z,GACW,OAAA3rB,KAAK2mB,mBAAmB,MAAOE,EAAI,CAOvC+E,OAAAA,GACP,QAAAC,EAAA7Z,UAAA3M,OADkBwhB,EAClB,IAAAG,MAAA6E,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADkBjF,EAClBiF,GAAA9Z,UAAA8Z,GACW,OAAA9rB,KAAK2mB,mBAAmB,UAAWE,EAAI,CAG3CkF,IAAAA,GAEH,OAAO/rB,KAAK2mB,mBAAmB,OAAQ,GAAE,CAMtCqF,YAAAA,GAEI,OAAAhsB,KAAK2T,QAAQqY,cAAa,CAO9BC,cAAAA,GAEH,OAAOjsB,KAAK2mB,mBAAmB,iBAAkB,GAAE,CAQhDuF,eAAAA,GACP,QAAAC,EAAAna,UAAA3M,OAD0BwhB,EAC1B,IAAAG,MAAAmF,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAD0BvF,EAC1BuF,GAAApa,UAAAoa,GACW,OAAApsB,KAAK2mB,mBAAmB,SAAUE,EAAI,CAU1CwF,cAAAA,GACP,QAAAC,EAAAta,UAAA3M,OADyBwhB,EACzB,IAAAG,MAAAsF,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADyB1F,EACzB0F,GAAAva,UAAAua,GACW,OAAAvsB,KAAK2mB,mBAAmB,QAASE,EAAI,CAgBzC2F,YAAAA,GACP,QAAAC,EAAAza,UAAA3M,OADuBwhB,EACvB,IAAAG,MAAAyF,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADuB7F,EACvB6F,GAAA1a,UAAA0a,GACW,OAAA1sB,KAAK2mB,mBAAmB,eAAgBE,EAAI,CAgBhDjP,SAAAA,GACP,QAAA+U,EAAA3a,UAAA3M,OADoBwhB,EACpB,IAAAG,MAAA2F,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADoB/F,EACpB+F,GAAA5a,UAAA4a,GACW,OAAA5sB,KAAK2mB,mBAAmB,YAAaE,EAAI,CAU7CgG,kBAAAA,GACP,QAAAC,EAAA9a,UAAA3M,OAD6BwhB,EAC7B,IAAAG,MAAA8F,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAD6BlG,EAC7BkG,GAAA/a,UAAA+a,GACW,OAAA/sB,KAAK2mB,mBAAmB,YAAaE,EAAI,CAO7CpiB,KAAAA,GAEH,OAAOzE,KAAK2mB,mBAAmB,QAAS,GAAE,CAM9C,aAAIqG,GAEA,OAAOhtB,KAAKqmB,SAAS2G,SAAA,CAEzB,aAAIA,CAAUtlB,GAEV1H,KAAKqmB,SAAS2G,UAAYtlB,CAAA,CAM9B,eAAIulB,GAEA,OAAOjtB,KAAKqmB,SAAS4G,WAAA,CAEzB,eAAIA,CAAYvlB,GAEZ1H,KAAKqmB,SAAS4G,YAAcvlB,CAAA,CAWzBwlB,KAAAA,GAEH,GAFSlb,UAAA3M,OAAA,QAAA4M,IAAAD,UAAA,IAAAA,UAAA,GAIL,OAAO,IAAIiU,EAASjmB,KAAKqmB,SAAS6G,SAGrCltB,KAAKsmB,cAAyB,KAGxB,OAFO,IAAIL,EAASjmB,KAAKqmB,SAEzB,CAWJ8G,SAAAA,CAAUrsB,EAAgBgY,EAAqB9F,IAIlDiG,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,gGAGpB,MAAM+T,EAAoC,CAAC,EASpC,OANPnsB,IAAUmsB,EAAYnsB,MAAQA,GAC9BgY,IAAUmU,EAAYnU,MAAQA,GAC9B9F,IAAUia,EAAYja,MAAQA,GAE9BhT,KAAK2T,QAAQsZ,YAAcA,EAEpBjtB,IAAA,CAQJotB,SAAAA,CAAUtU,EAAoB9F,IAIjCiG,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,uGAGpB,MAAM8T,EAAgC,CAAC,EAQhC,OALPlU,IAAUkU,EAAUlU,MAAQA,GAC5B9F,IAAUga,EAAUha,MAAQA,GAE5BhT,KAAK2T,QAAQqZ,UAAYA,EAElBhtB,IAAA,CAMJqtB,OAAAA,IAIHpU,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,qGAGpBlZ,KAAK2T,QAAQ0T,OACP,MAAA4F,EAAcjtB,KAAK2T,QAAQsZ,YAS1B,OAPHA,EAAYnsB,QAAUqlB,EAAAA,EAAgBmH,mBAAmBxsB,OACtDmsB,EAAYnU,QAAUqN,EAAAA,EAAgBmH,mBAAmBxU,OACzDmU,EAAYja,QAAUmT,EAAAA,EAAgBmH,mBAAmBta,OAE5DhT,KAAK2T,QAAQ6T,SAGVxnB,IAAA,CAOJutB,UAAAA,IAGHtU,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,2DAAyD,QAAAsU,EAAAxb,UAAA3M,OAH5DwhB,EACrB,IAAAG,MAAAwG,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADqB5G,EACrB4G,GAAAzb,UAAAyb,GAKW,OAAAztB,KAAK2mB,mBAAmB,SAAUE,EAAI,CAO1C6G,WAAAA,IAGHzU,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,6DAA2D,QAAAyU,EAAA3b,UAAA3M,OAH7DwhB,EACtB,IAAAG,MAAA2G,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADsB/G,EACtB+G,GAAA5b,UAAA4b,GAKW,OAAA5tB,KAAK2mB,mBAAmB,UAAWE,EAAI,CAO3CgH,WAAAA,IAGH5U,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,0DAAwD,QAAA4U,EAAA9b,UAAA3M,OAH1DwhB,EACtB,IAAAG,MAAA8G,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADsBlH,EACtBkH,GAAA/b,UAAA+b,GAKW,OAAA/tB,KAAK2mB,mBAAmB,OAAQE,EAAI,CAOxCmH,QAAAA,IAGH/U,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,uDAAqD,QAAA+U,EAAAjc,UAAA3M,OAH1DwhB,EACnB,IAAAG,MAAAiH,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADmBrH,EACnBqH,GAAAlc,UAAAkc,GAKW,OAAAluB,KAAK2mB,mBAAmB,OAAQE,EAAI,CAOxCsH,eAAAA,IAGHlV,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,mEAAiE,QAAAkV,EAAApc,UAAA3M,OAH/DwhB,EAC1B,IAAAG,MAAAoH,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAD0BxH,EAC1BwH,GAAArc,UAAAqc,GAKW,OAAAruB,KAAK2mB,mBAAmB,YAAaE,EAAI,CAO7CyH,QAAAA,IAGHrV,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,uDAAqD,QAAAqV,EAAAvc,UAAA3M,OAH1DwhB,EACnB,IAAAG,MAAAuH,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADmB3H,EACnB2H,GAAAxc,UAAAwc,GAKW,OAAAxuB,KAAK2mB,mBAAmB,OAAQE,EAAI,E,6FC91B5C,MAAM4H,EAAsB,CAC/BtqB,KAAM,yBACNiL,OAAQ,CACJC,OAAkB,iSAUlBC,KAAgB,sHAIhBC,IAAe,+LAOnB6O,SAAU,CACN/O,OAAkB,oQASlBC,KAAgB,gIAOXof,EAAwB,CACjCvqB,KAAM,yBACNiL,OAAQ,CACJC,OAAkB,8HAKlBC,KAAgB,0FAIhBC,IAAe,sJAOnB6O,SAAU,CACN/O,OAAkB,oDAGlBC,KAAgB,+FCnEXqf,EAAU,CACnBxqB,KAAM,WACNia,SAAU,CACN/O,OAAkB,8lCAgCbuf,EAAY,CACrBzqB,KAAM,WACNia,SAAU,CACN/O,OAAkB,+nCCjB1B,IAAIgP,EACAhE,EAEG,MAAMwU,UAAkB5Q,EAAAA,EAE3Bpb,WAAAA,GAEU,MAAA6J,EAAW,IAAIlF,EAAAA,EAAa,CAC9B6N,OAAQ,CAAE3N,MAAO,IAAIZ,aAAa,CAAC,EAAG,EAAG,EAAG,IAAK/C,KAAM,aACvDkR,iBAAkB,CAAEvN,MAAO,IAAIrD,EAAAA,EAAUN,KAAM,eAC/C+qB,UAAW,CAAEpnB,MAAO,EAAG3D,KAAM,OAC7BmR,OAAQ,CAAExN,MAAO,EAAG3D,KAAM,SAGxBgrB,GAAcC,EAAAA,EAAAA,KAEpB3Q,IAAAA,GAAewE,EAAAA,EAAAA,GAA4B,CACvC1e,KAAM,aACN2e,KAAM,CACFmM,EAAAA,GACAC,EAAAA,EAAAA,GAAwBH,GACxBN,EACAE,EACA5L,EAAAA,MAIR1I,IAAAA,GAAc2I,EAAAA,EAAAA,GAA2B,CACrC7e,KAAM,aACN2e,KAAM,CACFqM,EAAAA,GACAC,EAAAA,EAAAA,GAA0BL,GAC1BL,EACAE,EACA3L,EAAAA,MAIF,OACF5I,YACAgE,aACArJ,UAAW,CACPD,cAAerI,EACf2iB,eAAeC,EAAAA,EAAAA,GAA6BP,KAEnD,E,wBClDF,MAAMQ,EAgBT1sB,WAAAA,CAAYxB,GAHZ,KAAQmuB,eAA2C,CAAC,EACpD,KAAiBpc,wBAA0BpT,KAAKqT,kBAAkBxI,KAAK7K,MAInEA,KAAK8C,UAAYzB,EACjBrB,KAAK8C,UAAUyQ,aAAaC,eAAexT,KAAM,iBAAgB,CAG9DyT,kBAAAA,CAAmBgc,GAEhB,MAAAC,EAAqB1vB,KAAK2vB,kBAAkBF,GASlD,OAPIA,EAAWG,iBAEXH,EAAWG,gBAAiB,EAEvB,KAAAC,eAAeJ,EAAYC,IAG7B1vB,KAAK8C,UAAUK,YAAYuQ,SAASD,mBAAmBic,EAAkB,CAO7Ezb,aAAAA,CAAcwb,EAAwBvsB,GAEnC,MAAAwsB,EAAqB1vB,KAAK2vB,kBAAkBF,GAGlDK,EAAcL,EAAYC,GAEtBD,EAAWG,iBAEXH,EAAWG,gBAAiB,EAEvB,KAAAC,eAAeJ,EAAYC,IAGpC1vB,KAAK8C,UAAUK,YAAYuQ,SAASO,cAAcyb,EAAoBxsB,GAElEwsB,EAAmB/b,QAAQkB,cAE3B7U,KAAK+vB,qBAAqBN,EAC9B,CAGGpc,iBAAAA,CAAkBoc,GAEVA,EAAA/a,IAAI,YAAa1U,KAAKoT,yBAE5B,KAAA4c,wBAAwBP,EAAWld,IAAG,CAGvCyd,uBAAAA,CAAwBC,GAE5B,MAAMtc,EAAU3T,KAAKwvB,eAAeS,GAAetc,QAE/CA,EAAQkB,eAEAiB,EAAAA,EAAAtP,OAAOmN,EAAQkB,cAEvBlB,EAAQkB,aAAe,MAG3BiB,EAAAA,EAAQtP,OAAOxG,KAAKwvB,eAAeS,IAC9B,KAAAT,eAAeS,GAAiB,KAGlC5b,gBAAAA,CAAiBob,GAEd,MAAAC,EAAqB1vB,KAAK2vB,kBAAkBF,GAGlDK,EAAcL,EAAYC,GAE1B1vB,KAAK8C,UAAUK,YAAYuQ,SAASW,iBAAiBqb,GAEjDA,EAAmB/b,QAAQkB,cAE3B7U,KAAK+vB,qBAAqBN,EAC9B,CAGII,cAAAA,CAAeJ,EAAwBS,GAErC,cAAEvc,GAAYuc,EAEdC,EAAaC,EAAAA,EAAkBC,QAAQZ,EAAWa,KAAMb,EAAWc,QAEzE5c,EAAQlP,QAE8B,SAAlC0rB,EAAWK,cAAczsB,OAEpB4P,EAAQkB,eAEDlB,EAAAkB,aAAeiB,EAAAA,EAAQrV,IAAIouB,KAI3C,MAAM4B,EAAQzJ,MAAM7I,KAAKsR,EAAWa,MAC9BhlB,EAAQmkB,EAAWc,OAEzB,IAAIG,EAAWP,EAAWQ,eAG1B,MAAMC,GAAmBC,EAAAA,EAAAA,GAAoBJ,EAAOnlB,EAAO6kB,GAAY,GAEvE,IAAI3K,EAAQ,EAEZ,MAAMnc,EAAUiC,EAAMjC,QAChBY,EAAQ2mB,EAAiB3mB,MAE/B,IAAIga,EAAK2M,EAAiB9vB,MACtBojB,EAAK0M,EAAiB7vB,OAAS6vB,EAAiBE,QAEhDxlB,EAAMylB,UAEA9M,GAAA3Y,EAAMylB,QAAQjwB,MAAQmJ,EACtBia,GAAA5Y,EAAMylB,QAAQjwB,MAAQmJ,GAGhC0J,EACK5E,WAAY0gB,EAAWuB,QAAQC,GAAKhN,EAAM5a,GAAWomB,EAAWuB,QAAQE,GAAKhN,EAAM7a,GACnFY,MAAMA,EAAOA,GAElB,MAAMknB,EAAOhB,EAAWiB,gBAAkB9lB,EAAM+lB,MAAMvY,MAAQ,SAE9D,IAAK,IAAI5S,EAAI,EAAGA,EAAI0qB,EAAiBU,MAAMjsB,OAAQa,IACnD,CACU,MAAAqrB,EAAOX,EAAiBU,MAAMprB,GAEpC,IAAK,IAAI0M,EAAI,EAAGA,EAAI2e,EAAKC,cAAcnsB,OAAQuN,IAC/C,CACU,MAAA6e,EAAOhB,EAAMjL,KAEbkM,EAAWvB,EAAWM,MAAMgB,GAE9BC,GAAU5iB,SAEF6E,EAAA7E,QACJ4iB,EAAS5iB,QACTqiB,GAAc,QACdznB,KAAKioB,MAAMJ,EAAKC,cAAc5e,GAAK8e,EAASE,SAC5CloB,KAAKioB,MAAMjB,EAAWgB,EAASG,SAEvC,CAGJnB,GAAYP,EAAW2B,UAAA,CAC3B,CAGInC,iBAAAA,CAAkBF,GAEtB,OAAOzvB,KAAKwvB,eAAeC,EAAWld,MAAQvS,KAAK+xB,YAAYtC,EAAU,CAGtEsC,WAAAA,CAAYtC,GAGT,MAAAuC,EAAkBlc,EAAAA,EAAQrV,IAAIwlB,GAQ7B,OANF,KAAAuJ,eAAeC,EAAWld,KAAOyf,EAEjC,KAAAnC,eAAeJ,EAAYuC,GAErBvC,EAAAzZ,GAAG,YAAahW,KAAKoT,yBAEzBpT,KAAKwvB,eAAeC,EAAWld,IAAG,CAGrCwd,oBAAAA,CAAqBN,GAEzB,MAAM9b,EAAU3T,KAAK2vB,kBAAkBF,GAAY9b,QAE7Cse,EAAaxC,EAAWc,OAAO0B,WAC/BC,EAAcC,EAAAA,EAAM1xB,IAAI,GAAGwxB,aAG3B,EAAEpO,EAAGC,EAAAA,EAAA,EAAGC,EAAGC,EAAAA,GAAMyL,EAAWzpB,eAE5BosB,EAAK1oB,KAAK2oB,KAAMxO,EAAIA,EAAMC,EAAIA,GAC9BwO,EAAK5oB,KAAK2oB,KAAMtO,EAAIA,EAAMC,EAAIA,GAC9BuO,GAAc7oB,KAAK8oB,IAAIJ,GAAM1oB,KAAK8oB,IAAIF,IAAO,EAE7CG,EAAYP,EAAYQ,qBAAuBjD,EAAWc,OAAOoC,SAEjEC,EAAWL,EAAaL,EAAY1B,cAAcqC,OAAS,EAAIJ,GAErE9e,EAAQkB,aAAaG,UAAUD,cAAcrI,SAASoiB,UAAY8D,CAAA,CAG/DpxB,OAAAA,GAEQ,UAAA+Q,KAAOvS,KAAKwvB,eAEnBxvB,KAAKgwB,wBAAwBzd,GAGjCvS,KAAKwvB,eAAiB,KAEtBxvB,KAAK8C,UAAY,MAIzB,SAASgtB,EAAc7sB,EAAuB6vB,GAE1CA,EAAM9sB,eAAiB/C,EAAU+C,eACjC8sB,EAAM1d,gBAAkBnS,EAAUmS,gBAClC0d,EAAMC,WAAa9vB,EAAU8vB,WAC7BD,EAAMhe,eAAiB7R,EAAU6R,eACjCge,EAAMlqB,oBAAsB3F,EAAU2F,oBACtCkqB,EAAM9sB,eAAiB/C,EAAU+C,eACjC8sB,EAAM7tB,mBAAqBhC,EAAUgC,mBACrC6tB,EAAME,WAAa/vB,EAAU+vB,WAC7BF,EAAM3d,aAAelS,EAAUkS,YACnC,CAxOaoa,EAGK9tB,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcsC,WACdtC,EAAAA,GAAcuC,YACdvC,EAAAA,GAAcwC,aAElBC,KAAM,cCtBdxB,EAAAA,GAAWR,IAAIotB,E,uECUR,MAAM0D,EAwBTpwB,WAAAA,CAAYxB,GAVJ,KAAA6xB,SAMIpzB,OAAAwR,OAAO,MAEnB,KAAiB8B,wBAA0BpT,KAAKqT,kBAAkBxI,KAAK7K,MAInEA,KAAK8C,UAAYzB,EACjBrB,KAAK8C,UAAUqwB,QAAQC,iBAAiBjxB,IAAInC,MAC5CA,KAAK8C,UAAUyQ,aAAaC,eAAexT,KAAM,WAAU,CAGxDozB,gBAAAA,GAEQ,UAAAltB,KAAKlG,KAAKkzB,SACrB,CACU,MAAAG,EAAUrzB,KAAKkzB,SAAShtB,GAE9B,IAAKmtB,EAAS,SAER,MAAA/C,EAAO+C,EAAQ7Q,gBAAgB7Z,WAEjC2nB,EAAKgD,kBAEAhD,EAAA1mB,YAAc5J,KAAK8C,UAAUqG,WAClCmnB,EAAK/J,eACT,CACJ,CAGG9S,kBAAAA,CAAmB8f,GAEhB,MAAAF,EAAUrzB,KAAKwzB,YAAYD,GAE3BE,EAASF,EAASG,UAExB,OAAIL,EAAQM,uBAERN,EAAQM,uBAAwB,GAEzB,GAGPN,EAAQO,aAAeH,CAQpB,CAGJxf,aAAAA,CAAcsf,EAAoBrwB,GAE/B,MAEAsf,EAFUxiB,KAAKwzB,YAAYD,GAED/Q,gBAE5B+Q,EAAS3D,gBAET5vB,KAAK6zB,YAAYN,GAGrBvzB,KAAK8C,UAAUK,YAAYC,MAAMsS,WAAW8M,EAAiBtf,EAAc,CAGxEmR,gBAAAA,CAAiBkf,GAEd,MACA/Q,EADUxiB,KAAKwzB,YAAYD,GACD/Q,gBAE5B+Q,EAAS3D,gBAET5vB,KAAK6zB,YAAYN,GAGL/Q,EAAAjO,SAASC,cAAcgO,EAAe,CAGnDnP,iBAAAA,CAAkBkgB,GAEZA,EAAA7e,IAAI,YAAa1U,KAAKoT,yBAC1B,KAAA0gB,uBAAuBP,EAAShhB,IAAG,CAGpCuhB,sBAAAA,CAAuBC,GAErB,MAAAV,EAAUrzB,KAAKkzB,SAASa,GAE9B/zB,KAAK8C,UAAUywB,SAASS,uBAAuBX,EAAQO,YAE/C9d,EAAAA,EAAAtP,OAAO6sB,EAAQ7Q,iBAElB,KAAA0Q,SAASa,GAAe,KAGzBF,WAAAA,CAAYN,GAEV,MAAAE,EAASF,EAASG,UAClBL,EAAUrzB,KAAKwzB,YAAYD,GAC3B/Q,EAAkB6Q,EAAQ7Q,gBAE5B6Q,EAAQO,aAAeH,GAEvBzzB,KAAKi0B,eAAeV,GAAUW,OAAOC,IAEjCC,QAAQC,MAAMF,EAAE,IAIxBZ,EAAS3D,gBAAiB,EAEpB,MAAAvmB,EAAUkqB,EAAShD,OAAOlnB,SAEhCirB,EAAAA,EAAAA,GAAiB9R,EAAgBhe,OAAQ+uB,EAASvC,QAASxO,EAAgB1T,QAASzF,EAAO,CAG/F,oBAAc4qB,CAAeV,GAEzBA,EAAS3D,gBAAiB,EAEpB,MAAAyD,EAAUrzB,KAAKwzB,YAAYD,GAEjC,GAAIF,EAAQkB,kBAAmB,OAEzB,MAAAd,EAASF,EAASG,UAExB1zB,KAAK8C,UAAUywB,SAASS,uBAAuBX,EAAQO,YAEvDP,EAAQkB,mBAAoB,EAE5BlB,EAAQO,WAAaH,EAErB,MAAMtqB,EAAaoqB,EAASpqB,YAAcnJ,KAAK8C,UAAUqG,WAEnD2F,QAAgB9O,KAAK8C,UAAUywB,SAASiB,kBAC1CjB,EAASjD,KACTnnB,EACAoqB,EAAShD,OACTgD,EAASG,WAGPlR,EAAkB6Q,EAAQ7Q,gBAEhBA,EAAA1T,QAAUukB,EAAQvkB,QAAUA,EAE5CukB,EAAQkB,mBAAoB,EAE5BlB,EAAQM,uBAAwB,EAChCJ,EAAShN,eAEH,MAAAld,EAAUkqB,EAAShD,OAAOlnB,SAEhCirB,EAAAA,EAAAA,GAAiB9R,EAAgBhe,OAAQ+uB,EAASvC,QAASxO,EAAgB1T,QAASzF,EAAO,CAGvFmqB,WAAAA,CAAYD,GAEhB,OAAOvzB,KAAKkzB,SAASK,EAAShhB,MAAQvS,KAAK+xB,YAAYwB,EAAQ,CAG5DxB,WAAAA,CAAYwB,GAEf,MAAMkB,EAAgD,CAClD3lB,QAAS/D,EAAAA,EAAQC,MACjB4oB,WAAY,KACZpR,gBAAiB1M,EAAAA,EAAQrV,IAAIslB,EAAAA,GAC7B4N,uBAAuB,EACvBY,mBAAmB,GAGjB/R,EAAkBiS,EAAYjS,gBAa7B,OAXPA,EAAgB7Z,WAAa4qB,EAC7B/Q,EAAgB5K,UAAY2b,EAASvtB,eACrCwc,EAAgB1T,QAAU/D,EAAAA,EAAQC,MAClBwX,EAAAhe,OAAS,CAAEoB,KAAM,EAAGE,KAAM,EAAGD,KAAM,EAAGE,KAAM,GAC5Dyc,EAAgB7M,YAAe3V,KAAK8C,UAAUqS,aAAeoe,EAASpe,aAEtEoe,EAAS3pB,YAAc2pB,EAASD,gBAAkBtzB,KAAK8C,UAAUqG,WAAaoqB,EAASpqB,WAClF,KAAA+pB,SAASK,EAAShhB,KAAOkiB,EAErBlB,EAAAvd,GAAG,YAAahW,KAAKoT,yBAEvBqhB,CAAA,CAGJjzB,OAAAA,GAEQ,UAAA0E,KAAKlG,KAAKkzB,SAEjBlzB,KAAK8zB,uBAAuB5tB,GAGhClG,KAAKkzB,SAAW,KAChBlzB,KAAK8C,UAAY,MAxNZmwB,EAGKxxB,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcsC,WACdtC,EAAAA,GAAcuC,YACdvC,EAAAA,GAAcwC,aAElBC,KAAM,Y,mECpBP,MAAMuwB,EAAQ,6BACRC,EAAU,+BAEhB,MAAMC,EAST/xB,WAAAA,GAPA,KAAOgyB,QAAUC,SAASC,gBAAgBL,EAAO,OACjD,KAAOM,cAAgBF,SAASC,gBAAgBL,EAAO,iBACvD,KAAOO,WAAaH,SAASC,gBAAgBJ,EAAS,OACtD,KAAOO,aAAeJ,SAASC,gBAAgBJ,EAAS,SACjD,KAAAQ,MAAQ,IAAIC,MAKf,MAAM,cAAEJ,EAAA,QAAeH,EAASK,aAAAA,EAAA,WAAcD,GAAej1B,KAG/Cg1B,EAAAK,aAAa,QAAS,SACtBL,EAAAK,aAAa,SAAU,SACrCL,EAAc1pB,MAAMgqB,SAAW,SAE/BT,EAAQU,YAAYP,GAEpBA,EAAcO,YAAYL,GAC1BF,EAAcO,YAAYN,EAAU,E,kCCfrC,SAASO,EAAelqB,GAE3B,MAAMkc,EAASlc,EAAMylB,QACf1J,EAAO/b,EAAM+lB,MAuBboE,EAAY,CAAC,SArBI,CACnB,UAAU5W,EAAAA,EAAMpc,OAAOizB,SAASrO,EAAKvO,OAAO6c,UAC5C,cAAerqB,EAAMqnB,aACrB,gBAAgBrnB,EAAM2mB,aACtB,gBAAgB3mB,EAAMsqB,aACtB,eAAetqB,EAAMuqB,YACrB,iBAAiBvqB,EAAMwqB,cACvB,mBAAmBxqB,EAAMyqB,kBACzB,eAAezqB,EAAM0qB,QACrB,YAAY1qB,EAAMjC,YAClB,gBAAsC,QAArBiC,EAAM2qB,YAAwB3qB,EAAM4qB,SAAY,WAAa5qB,EAAM2qB,gBACjF3qB,EAAMwmB,WAAa,CAAC,gBAAgBxmB,EAAMwmB,gBAAkB,MAC5DxmB,EAAM4qB,SAAW,CAChB,eAAc5qB,EAAM6qB,WAAa,YAAc,cAC/C,cAAc7qB,EAAM8qB,mBACpB,MACD5O,EAAS,CAAC6O,EAAY7O,IAAW,MACjClc,EAAMgrB,WAAa,CAACC,EAAgBjrB,EAAMgrB,aAAe,MACzDhrB,EAAMkrB,cACX5a,KAAK,UAMA,OAqDX,SAAuB6a,EAAiD1jB,GAEpE,IAAK,MAAM7M,KAAKuwB,EAChB,CACU,MAAAC,EAAWD,EAAUvwB,GACrBywB,EAAc,GAEpB,IAAK,MAAM/jB,KAAK8jB,EAER9e,EAAUhF,GAGV+jB,EAAY5zB,KAAK6U,EAAUhF,GAA6B8jB,EAAS9jB,KAE5DgkB,EAAUhkB,IAGH+jB,EAAA5zB,KAAK6zB,EAAUhkB,GAA6BnD,QAAQ,YAAainB,EAAS9jB,KAI1FG,EAAAhQ,KAAK,GAAGmD,OAAOywB,EAAY/a,KAAK,SAAQ,CAEpD,CA9EkBib,CAAAvrB,EAAMmrB,UAAWhB,GAExBA,EAAU7Z,KAAK,IAC1B,CAEA,SAAS2a,EAAgBO,GAEf,MAAAhe,EAAQ+F,EAAAA,EAAMpc,OAAOizB,SAASoB,EAAgBhe,OAAOie,SAASD,EAAgB9jB,OAAOgkB,SAIrFC,EAAW,GAHPvtB,KAAKioB,MAAMjoB,KAAKwtB,IAAIJ,EAAgBK,OAASL,EAAgBlE,eAC7DlpB,KAAKioB,MAAMjoB,KAAK0tB,IAAIN,EAAgBK,OAASL,EAAgBlE,cAInE,OAAAkE,EAAgBO,KAAO,EAEhB,gBAAgBJ,KAAYH,EAAgBO,UAAUve,IAG1D,gBAAgBme,KAAYne,GACvC,CAEA,SAASud,EAAY7O,GAEV,OACH,8BAA8BA,EAAO1mB,UACrC,8BAA8B+d,EAAAA,EAAMpc,OAAOizB,SAASlO,EAAO1O,OAAO6c,UAClE,sBAAsBnO,EAAO1mB,UAC7B,sBAAsB+d,EAAAA,EAAMpc,OAAOizB,SAASlO,EAAO1O,OAAO6c,UAC1D,uBACF/Z,KAAK,IACX,CAGA,MAAMgb,EAAY,CACdjE,SAAU,yBACVV,WAAY,yBACZ2D,WAAY,yBACZC,UAAW,wBACXC,YAAa,0BACbC,cAAe,8BACfC,MAAO,wBACP3sB,QAAS,uBACT4sB,WAAY,yBACZnE,WAAY,2BACZsE,cAAe,0BAIbxe,EAAY,CACdyP,KAAO3f,GAAkB,UAAUmX,EAAAA,EAAMpc,OAAOizB,SAAShuB,GAAOiuB,UAChEQ,WAAazuB,GAAkB,eAAcA,EAAQ,YAAc,cACnE8f,OAAQ6O,EACRC,WAAYC,GCjET,MAAMe,UAAsBC,EAAAA,EA6B/B10B,WAAAA,GACA,IADYhD,EAAgCmS,UAAA3M,OAAA,QAAA4M,IAAAD,UAAA,GAAAA,UAAA,MAExC8N,MAAMjgB,GA7BV,KAAQ23B,cAA0B,GA+BzB,KAAAhB,eAALx2B,KAAKw2B,aAAiB32B,EAAQ22B,cACzB,KAAAC,UAAY52B,EAAQ42B,WAAa,CAAC,EAI3C,gBAAID,CAAa9uB,GAEb1H,KAAKw3B,cAAgB9vB,aAAiBsf,MAAQtf,EAAQ,CAACA,GACvD1H,KAAKwN,QAAO,CAGhB,gBAAIgpB,GAEA,OAAOx2B,KAAKw3B,aAAA,CAGGC,YAAAA,GAIf,OAFAz3B,KAAK03B,WAAYC,EAAAA,EAAAA,GAAqB33B,MAAQA,KAAKw3B,cAAc5b,KAAK,KAE/D5b,KAAK03B,SAAA,CAGTlqB,MAAAA,GAEHxN,KAAK43B,UAAY,KACjB9X,MAAMtS,QAAO,CAOV0f,KAAAA,GAEH,OAAO,IAAIoK,EAAc,CACrBtB,MAAOh2B,KAAKg2B,MACZG,WAAYn2B,KAAKm2B,WACjBG,WAAYt2B,KAAKs2B,WAAa,IAAKt2B,KAAKs2B,YAAe,KACvDjP,KAAMrnB,KAAKqxB,MACXY,WAAYjyB,KAAKiyB,WACjBU,SAAU3yB,KAAK2yB,SACfkD,UAAW71B,KAAK61B,UAChBC,YAAa91B,KAAK81B,YAClBF,WAAY51B,KAAK41B,WACjBG,cAAe/1B,KAAK+1B,cACpBjE,WAAY9xB,KAAK8xB,WACjBzoB,QAASrJ,KAAKqJ,QACdme,OAAQxnB,KAAK+wB,QACbkF,WAAYj2B,KAAKi2B,WACjBC,SAAUl2B,KAAKk2B,SACfE,cAAep2B,KAAKo2B,cACpBI,aAAcx2B,KAAKw2B,cACtB,CAGL,YAAIqB,GAOA,OALK73B,KAAK43B,YAED,KAAAA,UAAYpC,EAAex1B,OAG7BA,KAAK43B,SAAA,CAYTE,WAAAA,GACP,QAAA/Q,EAAA/U,UAAA3M,OADsBqC,EACtB,IAAAsf,MAAAD,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IADsBvf,EACtBuf,GAAAjV,UAAAiV,GACU,MAAA8Q,EAAQrwB,EAAM5D,QAAQk0B,IAAOh4B,KAAKw2B,aAAayB,SAASD,KAE1DD,EAAM1yB,OAAS,IAEV,KAAAmxB,aAAazzB,QAAQg1B,GAC1B/3B,KAAKwN,SACT,CASG0qB,cAAAA,GACP,QAAA/Q,EAAAnV,UAAA3M,OADyBqC,EACzB,IAAAsf,MAAAG,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADyB1f,EACzB0f,GAAApV,UAAAoV,GACU,MAAA+Q,EAAWzwB,EAAM5D,QAAQk0B,GAAMh4B,KAAKw2B,aAAayB,SAASD,KAE5DG,EAAS9yB,OAAS,IAEb,KAAAmxB,aAAex2B,KAAKw2B,aAAa1yB,QAAQk0B,IAAOG,EAASF,SAASD,KACvEh4B,KAAKwN,SACT,CAGJ,QAAa6Z,CAAK3f,GAGO,kBAAVA,GAAuC,kBAAVA,IAGpCsC,EAAAA,EAAAA,GAAK,gEAIT8V,MAAMuH,KAAO3f,CAAA,CAGjB,UAAa8f,CAAO9f,GAGZA,GAA0B,kBAAVA,GAAuC,kBAAVA,IAG7CsC,EAAAA,EAAAA,GAAK,kEAIT8V,MAAM0H,OAAS9f,CAAA,E,cCzKD,eAAA0wB,EAAY9sB,EAA4B+sB,GAEpD,MAAAC,QCXV,eAAuCD,GAEnC,MAAME,QAAiBC,EAAAA,EAAW/3B,MAAMg4B,MAAMJ,GAExCK,QAAaH,EAASG,OAEtBC,EAAS,IAAIC,WASZ,aAPuB,IAAIC,SAAS,CAAAC,EAASC,KAEhDJ,EAAOK,UAAY,IAAMF,EAAQH,EAAOM,QACxCN,EAAOO,QAAUH,EACjBJ,EAAOQ,cAAcT,EAAK,GAIlC,CDL0BU,CAAiBf,GAEhC,6CACa/sB,EAAM2mB,mCACVqG,8BACGhtB,EAAMsqB,oCACPtqB,EAAMuqB,mBAE5B,CErBa,MAAAwD,EAAA,IAA4BC,I,cCCzC,IAAIC,EC4BG,MAAMC,EA4BT32B,WAAAA,CAAYxB,GAVZ,KAAQo4B,gBAAmD,CAAC,EAYxDz5B,KAAK8C,UAAYzB,EACZ,KAAAq4B,cAAgBr4B,EAAS0C,OAASqK,EAAAA,EAAaurB,MAAA,CAGjDC,UAAAA,CAAW/5B,GAEd,OAAOG,KAAK65B,qBACRh6B,EAAQywB,KACRzwB,EAAQsJ,WACRtJ,EAAQyL,MACZ,CAGGkpB,iBAAAA,CACHlE,EACAnnB,EACAmC,EACAwuB,GAGI,GAAA95B,KAAKy5B,gBAAgBK,GAId,OAFP95B,KAAK+5B,wBAAwBD,GAEtB95B,KAAKy5B,gBAAgBK,GAASE,QAGnC,MAAAA,EAAUh6B,KAAK65B,qBAAqBvJ,EAAMnnB,EAAYmC,GACvD2uB,MAAMnrB,IAEE,KAAA2qB,gBAAgBK,GAAShrB,QAAUA,EAEjCA,KASR,OANF,KAAA2qB,gBAAgBK,GAAW,CAC5BhrB,QAAS,KACTkrB,UACAE,WAAY,GAGTF,CAAA,CAGX,0BAAcH,CACVvJ,EACAnnB,EACAmC,GAGM,MAAA6uB,EAAerkB,EAAAA,EAAQrV,IAAIm0B,GAC3BwF,EC1GE,SAAoB9J,EAAchlB,GAE9C,MAAM2mB,EAAa3mB,EAAM2mB,WACnBmI,EAAyB,GACzBC,EAAkC,CAAC,EAMnCC,EAAUhK,EAAKiK,MAFP,2BAId,SAASC,EAAcC,GAEdJ,EAAOI,KAERL,EAAar3B,KAAK03B,GAElBJ,EAAOI,IAAc,EACzB,CAGA,GAAAzT,MAAM0T,QAAQzI,GAEd,IAAK,IAAI/rB,EAAI,EAAGA,EAAI+rB,EAAW5sB,OAAQa,IAErBs0B,EAAAvI,EAAW/rB,SAK7Bs0B,EAAcvI,GAGdqI,GAEQA,EAAApkB,SAASqkB,IAIbC,EAFmBD,EAAMI,MAAM,KAAK,GAAGC,OAEd,IAItB,UAAA10B,KAAKoF,EAAMmrB,UAIlB+D,EAFmBlvB,EAAMmrB,UAAUvwB,GAAG+rB,YAKnC,OAAAmI,CACX,CDsD6BS,CAAoBvK,EAAMhlB,GACzCwvB,QFnGQ,eAClBV,EACA9uB,EACA6N,GAGA,MAAM4hB,EAAeX,EAChBt2B,QAAQmuB,GAAeE,EAAAA,EAAM6I,IAAI,GAAG/I,eACpCrc,KAAK,CAAAqc,EAAY/rB,KAEd,IAAKmzB,EAAsB2B,IAAI/I,GAC/B,CACI,MAAM,IAAEoG,GAAQlG,EAAAA,EAAM1xB,IAAI,GAAGwxB,aAEnB,IAAN/rB,EAEsBmzB,EAAAp5B,IAAIgyB,EAAYmG,EAAY,CAC9CxC,WAAYtqB,EAAMsqB,WAClBC,UAAWvqB,EAAMuqB,UACjB5D,cACDoG,IAKmBgB,EAAAp5B,IAAIgyB,EAAYmG,EAAY,CAC9CxC,WAAYzc,EAAeyc,WAC3BC,UAAW1c,EAAe0c,UAC1B5D,cACDoG,GACP,CAGG,OAAAgB,EAAsB54B,IAAIwxB,EAAW,IAGpD,aAAc4G,QAAQoC,IAAIF,IAAenf,KAAK,KAClD,CE8D8Bsf,CAClBd,EACA9uB,EACAgsB,EAAc6D,kBAEZC,EDxGP,SACH9K,EACAhlB,EACA+vB,EACAC,GAGAA,EAAqBA,GAAsB/B,IAA2BA,EAAyB,IAAI3E,GAEnG,MAAM,WAAEK,EAAA,aAAYC,EAAcL,QAAAA,GAAYyG,EAE9CrG,EAAWsG,UAAY,UAAUjwB,EAAMusB,2CAA2CvH,UAEvE2E,EAAAI,aAAa,QAAS,qDAE7BgG,IAEAnG,EAAasG,YAAcH,GAItBvG,SAAA2G,KAAKlG,YAAYV,GAEpB,MAAA6G,EAAgBzG,EAAW0G,wBAEjC9G,EAAQ3yB,SAER,MAAM05B,EAAmBC,EAAAA,EAAkBC,YAAYxwB,EAAMuqB,WAAWkG,QAGlEC,EAAgC,EAAhB1wB,EAAMjC,QAErB,OACHvI,MAAO46B,EAAc56B,MAAQk7B,EAC7Bj7B,OAAQ26B,EAAc36B,OAAS66B,EAAmBI,EAE1D,CCoEyBC,CAAgB3L,EAAMhlB,EAAOwvB,EAASX,GAEjDr5B,EAAQ4I,KAAKW,KAAKX,KAAKW,KAAMX,KAAKuG,IAAI,EAAGmrB,EAASt6B,OAA0B,EAAhBwK,EAAMjC,SAAiBF,GACnFpI,EAAS2I,KAAKW,KAAKX,KAAKW,KAAMX,KAAKuG,IAAI,EAAGmrB,EAASr6B,QAA2B,EAAhBuK,EAAMjC,SAAiBF,GAErFgsB,EAAQgF,EAAahF,MAKrBA,EAAAr0B,MAFe,GAEE,EAARA,GACTq0B,EAAAp0B,OAHe,GAGI,EAATA,GAEhB,MAAMm7B,EE1HP,SACH5L,EACAhlB,EACAnC,EACA2xB,EACAX,GAGA,MAAM,WAAElF,EAAA,aAAYC,EAAcL,QAAAA,GAAYsF,EAE9ClF,EAAWsG,UAAY,UAAUjwB,EAAMusB,2CAA2CvH,UAClF2E,EAAWI,aAAa,QAAS,oBAAoBlsB,wDACrD+rB,EAAasG,YAAcV,EAE3B,MAAM,MAAEh6B,EAAA,OAAOC,GAAWo5B,EAAahF,MAKvC,OAHAN,EAAQQ,aAAa,QAASv0B,EAAMiQ,YACpC8jB,EAAQQ,aAAa,SAAUt0B,EAAOgQ,aAE/B,IAAIorB,eAAgBC,kBAAkBvH,EACjD,CFsGuBwH,CAAU/L,EAAMhlB,EAAOnC,EAAY2xB,EAASX,SG5HnD,SAAahF,EAAyBkD,EAAaiE,GAExD,WAAIzD,SAAc0D,UAMjBD,SAEM,IAAIzD,SAAe2D,GAAYC,WAAWD,EAAS,OAG7DrH,EAAMuH,OAAS,KAEH5D,GAAA,EAGZ3D,EAAMwH,IAAM,mCAAmCC,mBAAmBvE,KAClElD,EAAM0H,YAAc,cAE5B,CHyGcC,CAAa3H,EAAO+G,EItI3B,WAEH,MAAM,UAAEa,GAAcvE,EAAAA,EAAW/3B,MAAMu8B,eAE/B,uCAAkCC,KAAKF,EACnD,CJiI0CG,IAAc9C,EAAa/0B,OAAS,GAEtE,MAAM83B,EAAiDhI,EACnD,IAAAiI,EAEAp9B,KAAK05B,gBAGc0D,EKjIf,SAA4BjI,EAAyBhsB,GAIjE,MAAMi0B,EAAmBC,EAAAA,EAAWC,2BAChCnI,EAAMr0B,MACNq0B,EAAMp0B,OACNoI,IAIE,QAAEwK,GAAYypB,EAMb,OAJPzpB,EAAQ4pB,UAAU,EAAG,EAAGpI,EAAMr0B,MAAOq0B,EAAMp0B,QACnC4S,EAAA6pB,UAAUrI,EAAO,EAAG,GAGrBiI,CACX,CL+G+BK,CAA4BtI,EAAOhsB,IAG1D,MAAM2F,GAAU4uB,EAAAA,EAAAA,GAAwBN,EAAmBA,EAAiBO,OAASR,EACjFhI,EAAMr0B,MAnBW,EAoBjBq0B,EAAMp0B,OApBW,EAqBjBoI,GAWG,OARHnJ,KAAK05B,gBAEL15B,KAAK8C,UAAUgM,QAAQ8uB,WAAW9uB,EAAQ5F,QAC1Cm0B,EAAAA,EAAWQ,uBAAuBT,IAGtCtnB,EAAAA,EAAQtP,OAAO2zB,GAERrrB,CAAA,CAGHirB,uBAAAA,CAAwBD,GAEvB,KAAAL,gBAAgBK,GAASI,YAAA,CAG3BlG,sBAAAA,CAAuB8F,GAEpB,MAAAgE,EAAgB99B,KAAKy5B,gBAAgBK,GAGtCgE,IAESA,EAAA5D,aAEmB,IAA7B4D,EAAc5D,aAEV4D,EAAchvB,QAEd9O,KAAK+9B,SAASD,GAKAA,EAAA9D,QAAQC,MAAMnrB,IAExBgvB,EAAchvB,QAAUA,EAExB9O,KAAK+9B,SAASD,EAAc,IAC7B5J,OAAM,MAGLlqB,EAAAA,EAAAA,GAAK,0CAA0C,IAKlD,KAAAyvB,gBAAgBK,GAAW,MACpC,CAGIiE,QAAAA,CAASD,GAEDnzB,EAAAA,EAAAa,cAAcsyB,EAAchvB,SAC1BgvB,EAAAhvB,QAAQ5F,OAAOi0B,SAAW,KAC1BW,EAAAhvB,QAAQ5F,OAAO80B,eAAiB,UAG3CC,iBAAAA,CAAkBnE,GAEd,OAAA95B,KAAKy5B,gBAAgBK,GAASI,UAAA,CAGlC14B,OAAAA,GAEHxB,KAAKy5B,gBAAkB,MAxLlBD,EAGK/3B,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcuN,YACdvN,EAAAA,GAAcwN,aACdxN,EAAAA,GAAcw8B,cAElB/5B,KAAM,YATDq1B,EAYK2E,mBAA0C,CACpDlM,WAAY,QACZ4D,UAAW,SACXD,WAAY,UM7CpBjzB,EAAAA,GAAWR,IAAIq3B,GACf72B,EAAAA,GAAWR,IAAI8wB,E,6DCOR,MAAMmL,EAsBTv7B,WAAAA,CAAYxB,GARJ,KAAA6xB,SAIIpzB,OAAAwR,OAAO,MAEnB,KAAiB8B,wBAA0BpT,KAAKqT,kBAAkBxI,KAAK7K,MAInEA,KAAK8C,UAAYzB,EACjBrB,KAAK8C,UAAUqwB,QAAQC,iBAAiBjxB,IAAInC,MAC5CA,KAAK8C,UAAUyQ,aAAaC,eAAexT,KAAM,WAAU,CAGxDozB,gBAAAA,GAEQ,UAAAltB,KAAKlG,KAAKkzB,SACrB,CACU,MAAAG,EAAUrzB,KAAKkzB,SAAShtB,GAE9B,IAAKmtB,EAAS,SAER,MAAA/C,EAAO+C,EAAQ7Q,gBAAgB7Z,WAEjC2nB,EAAKgD,kBAEAhD,EAAA1mB,YAAc5J,KAAK8C,UAAUqG,WAClCmnB,EAAK/J,eACT,CACJ,CAGG9S,kBAAAA,CAAmB6c,GAEhB,MAAA+C,EAAUrzB,KAAKwzB,YAAYlD,GAE3BmD,EAASnD,EAAKoD,UAEhB,OAAAL,EAAQO,aAAeH,CAKpB,CAGJxf,aAAAA,CAAcqc,EAAYptB,GAEvB,MAEAsf,EAFUxiB,KAAKwzB,YAAYlD,GAED9N,gBAE5B8N,EAAKV,gBAEL5vB,KAAK6zB,YAAYvD,GAGrBtwB,KAAK8C,UAAUK,YAAYC,MAAMsS,WAAW8M,EAAiBtf,EAAc,CAGxEmR,gBAAAA,CAAiBic,GAEd,MACA9N,EADUxiB,KAAKwzB,YAAYlD,GACD9N,gBAE5B8N,EAAKV,gBAEL5vB,KAAK6zB,YAAYvD,GAGL9N,EAAAjO,SAASC,cAAcgO,EAAe,CAGnDnP,iBAAAA,CAAkBid,GAEhBA,EAAA5b,IAAI,YAAa1U,KAAKoT,yBAEtB,KAAA0gB,uBAAuBxD,EAAK/d,IAAG,CAGhCuhB,sBAAAA,CAAuBuK,GAErB,MAAAhL,EAAUrzB,KAAKkzB,SAASmL,GAE9Br+B,KAAK8C,UAAUw7B,WAAWtK,uBAAuBX,EAAQO,YAEjD9d,EAAAA,EAAAtP,OAAO6sB,EAAQ7Q,iBAElB,KAAA0Q,SAASmL,GAAW,KAGrBxK,WAAAA,CAAYvD,GAEV,MAAAmD,EAASnD,EAAKoD,UACdL,EAAUrzB,KAAKwzB,YAAYlD,GAC3B9N,EAAkB6Q,EAAQ7Q,gBAE5B6Q,EAAQO,aAAeH,GAEvBzzB,KAAKi0B,eAAe3D,GAGxBA,EAAKV,gBAAiB,EAEhB,MAAAvmB,EAAUinB,EAAKC,OAAOlnB,SAE5BirB,EAAAA,EAAAA,GAAiB9R,EAAgBhe,OAAQ8rB,EAAKU,QAASxO,EAAgB1T,QAASzF,EAAO,CAGnF4qB,cAAAA,CAAe3D,GAEb,MAAA+C,EAAUrzB,KAAKwzB,YAAYlD,GAC3B9N,EAAkB6Q,EAAQ7Q,gBAE5B6Q,EAAQvkB,SAER9O,KAAK8C,UAAUw7B,WAAWtK,uBAAuBX,EAAQO,YAG7DP,EAAQvkB,QAAU0T,EAAgB1T,QAAU9O,KAAK8C,UAAUw7B,WAAW9J,kBAAkBlE,GAChF+C,EAAAO,WAAatD,EAAKoD,UAC1BlR,EAAgB1T,QAAUukB,EAAQvkB,OAAA,CAG9B0kB,WAAAA,CAAYlD,GAEhB,OAAOtwB,KAAKkzB,SAAS5C,EAAK/d,MAAQvS,KAAK+xB,YAAYzB,EAAI,CAGpDyB,WAAAA,CAAYzB,GAEf,MAAMmE,EAAkD,CACpD3lB,QAAS,KACT8kB,WAAY,KACZpR,gBAAiB1M,EAAAA,EAAQrV,IAAIslB,EAAAA,IAgB1B,OAbP0O,EAAYjS,gBAAgB7Z,WAAa2nB,EAC7BmE,EAAAjS,gBAAgB5K,UAAY0Y,EAAKtqB,eACjCyuB,EAAAjS,gBAAgBhe,OAAS,CAAEoB,KAAM,EAAGE,KAAM,EAAGD,KAAM,EAAGE,KAAM,GACxE0uB,EAAYjS,gBAAgB7M,YAAe3V,KAAK8C,UAAUqS,aAAemb,EAAKnb,aAEzE,KAAA+d,SAAS5C,EAAK/d,KAAOkiB,EAE1BnE,EAAK1mB,YAAc0mB,EAAKgD,gBAAkBtzB,KAAK8C,UAAUqG,WAAamnB,EAAKnnB,WAC3EnJ,KAAK6zB,YAAYvD,GAGZA,EAAAta,GAAG,YAAahW,KAAKoT,yBAEnBqhB,CAAA,CAGJjzB,OAAAA,GAEQ,UAAA0E,KAAKlG,KAAKkzB,SAEjBlzB,KAAK8zB,uBAAuB5tB,GAGhClG,KAAKkzB,SAAW,KAChBlzB,KAAK8C,UAAY,MAhLZs7B,EAGK38B,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcsC,WACdtC,EAAAA,GAAcuC,YACdvC,EAAAA,GAAcwC,aAElBC,KAAM,Q,sDCjBd,SAASo6B,EAAS7vB,EAAyB5N,EAAeiL,GAE7C,QAAAD,EAAI,EAAG0Z,EAAQ,EAAIzZ,EAAIjL,EAAOgL,EAAIhL,IAASgL,EAAG0Z,GAAS,EAExD,GAAoB,IAApB9W,EAAK8W,EAAQ,GAAiB,SAG/B,QACX,CAEA,SAASgZ,EAAY9vB,EAAyB5N,EAAegL,EAAW2yB,EAAaC,GAEjF,MAAM13B,EAAS,EAAIlG,EAEnB,IAAK,IAAIiL,EAAI0yB,EAAKjZ,EAASiZ,EAAMz3B,EAAW,EAAI8E,EAAIC,GAAK2yB,IAAU3yB,EAAGyZ,GAASxe,EAEvE,GAAoB,IAApB0H,EAAK8W,EAAQ,GAAiB,SAG/B,QACX,C,gECOO,MAAMmZ,EAoBT97B,WAAAA,CAAYC,GARZ,KAAQ22B,gBAIH,CAAC,EAMFz5B,KAAK8C,UAAYA,CAAA,CAGd87B,cAAAA,CAAetO,EAAcnnB,EAAoBmC,GAEpD,MAAM8vB,EAAWS,EAAAA,EAAkBgD,YAAYvO,GAAQ,IAAKhlB,GAE5D,IAAIxK,EAAQ4I,KAAKW,KAAKX,KAAKW,KAAMX,KAAKuG,IAAI,EAAGmrB,EAASt6B,OAA0B,EAAhBwK,EAAMjC,SAAiBF,GACnFpI,EAAS2I,KAAKW,KAAKX,KAAKW,KAAMX,KAAKuG,IAAI,EAAGmrB,EAASr6B,QAA2B,EAAhBuK,EAAMjC,SAAiBF,GAOlF,OALCrI,EAAA4I,KAAKW,KAAMvJ,EAAS,MACnBC,EAAA2I,KAAKW,KAAMtJ,EAAU,MAC9BD,GAAQsR,EAAAA,EAAAA,IAAStR,GACjBC,GAASqR,EAAAA,EAAAA,IAASrR,GAEX,CAAED,QAAOC,SAAO,CAepB64B,UAAAA,CAAW/5B,EAA+BsJ,EAAqBmC,EAAmBwzB,GAE9D,kBAAZj/B,KAEPoZ,EAAAA,EAAAA,IAAY,QAAS,qFAEXpZ,EAAA,CACNywB,KAAMzwB,EACNyL,QACAnC,eAIFtJ,EAAQyL,iBAAiBisB,EAAAA,IAE3B13B,EAAQyL,MAAQ,IAAIisB,EAAAA,EAAU13B,EAAQyL,QAG1C,MAAM,QAAEwD,EAAA,iBAASsuB,GAAqBp9B,KAAK++B,uBACvCl/B,GAOG,OAJPG,KAAK8C,UAAUgM,QAAQ8uB,WAAW9uB,EAAQF,SAE1CyuB,EAAAA,EAAWQ,uBAAuBT,GAE3BtuB,CAAA,CAGJiwB,sBAAAA,CAAuBl/B,GAEpB,WAAEywB,EAAMhlB,MAAAA,GAAUzL,EAElBsJ,EAAatJ,EAAQsJ,YAAcnJ,KAAK8C,UAAUqG,WAGlDiyB,EAAWS,EAAAA,EAAkBgD,YAAYvO,GAAQ,IAAKhlB,GAEtDxK,EAAQ4I,KAAKW,KAAKX,KAAKW,KAAMX,KAAKuG,IAAI,EAAGmrB,EAASt6B,OAA0B,EAAhBwK,EAAMjC,SAAiBF,GACnFpI,EAAS2I,KAAKW,KAAKX,KAAKW,KAAMX,KAAKuG,IAAI,EAAGmrB,EAASr6B,QAA2B,EAAhBuK,EAAMjC,SAAiBF,GAErFi0B,EAAmBC,EAAAA,EAAWC,2BAA2Bx8B,EAAOC,IAGhE,OAAE48B,GAAWP,EAEnBp9B,KAAKg/B,mBAAmB1O,EAAMhlB,EAAOnC,EAAYi0B,GAEjD,MAAMtuB,GAAU4uB,EAAAA,EAAAA,GAAwBC,EAAQ78B,EAAOC,EAAQoI,GAE/D,GAAImC,EAAMsvB,KACV,CACU,MAAAqE,EDrGF,SAAqBtB,GACrC,IADsDx0B,EAAA6I,UAAA3M,OAAA,QAAA4M,IAAAD,UAAA,GAAAA,UAAA,GAAa,EAIzD,YAAElR,EAAOC,OAAAA,GAAW48B,EAEpBhqB,EAAUgqB,EAAOuB,WAAW,KAAM,CACpCC,oBAAoB,IAGxB,GAAgB,OAAZxrB,EAEM,UAAIyrB,UAAU,mCAGxB,MACM1wB,EADYiF,EAAQ0rB,aAAa,EAAG,EAAGv+B,EAAOC,GAC7B2N,KAEvB,IAAI4wB,EAAO,EACPb,EAAM,EACNc,EAAQz+B,EAAQ,EAChB49B,EAAS39B,EAAS,EAEtB,KAAO09B,EAAM19B,GAAUw9B,EAAS7vB,EAAM5N,EAAO29B,MAAQA,EACrD,GAAIA,IAAQ19B,EAAQ,OAAOy+B,EAAAA,EAAUx0B,MAC9B,KAAAuzB,EAAS7vB,EAAM5N,EAAO49B,MAAWA,EACxC,KAAOF,EAAY9vB,EAAM5N,EAAOw+B,EAAMb,EAAKC,MAAWY,EACtD,KAAOd,EAAY9vB,EAAM5N,EAAOy+B,EAAOd,EAAKC,MAAWa,EAKhD,QAHLA,IACAb,EAEK,IAAIc,EAAAA,EAAUF,EAAOn2B,EAAYs1B,EAAMt1B,GAAao2B,EAAQD,GAAQn2B,GAAau1B,EAASD,GAAOt1B,EAC5G,CCoE4Bs2B,CAAqB9B,EAAQx0B,GAErC2F,EAAA3B,MAAMmY,SAAS2Z,GAEvBnwB,EAAQwD,WAAU,CAGf,OAAExD,UAASsuB,mBAAiB,CAGhC5I,iBAAAA,CAAkBlE,GAErBA,EAAK1mB,YAAc0mB,EAAKgD,gBAAkBtzB,KAAK8C,UAAUqG,WAAamnB,EAAKnnB,WACrE,MAAA2wB,EAAUxJ,EAAKoD,UAEjB,GAAA1zB,KAAKy5B,gBAAgBK,GAId,OAFP95B,KAAK+5B,wBAAwBD,GAEtB95B,KAAKy5B,gBAAgBK,GAAShrB,QAGzC,MAAM,QAAEA,EAASsuB,iBAAAA,GAAqBp9B,KAAK++B,uBAAuBzO,GAQ3D,OANF,KAAAmJ,gBAAgBK,GAAW,CAC5BsD,mBACAtuB,UACAorB,WAAY,GAGTprB,CAAA,CAGHirB,uBAAAA,CAAwBD,GAEvB,KAAAL,gBAAgBK,GAASI,YAAA,CAG3BlG,sBAAAA,CAAuB8F,GAEpB,MAAAgE,EAAgB99B,KAAKy5B,gBAAgBK,GAIvC,GAFUgE,EAAA5D,aAEmB,IAA7B4D,EAAc5D,WAClB,CACemD,EAAAA,EAAAQ,uBAAuBC,EAAcV,kBACpCzyB,EAAAA,EAAAa,cAAcsyB,EAAchvB,SAElC,MAAA5F,EAAS40B,EAAchvB,QAAQ5F,OAErCA,EAAOi0B,SAAW,KAClBj0B,EAAO80B,eAAiB,UACxB90B,EAAOw2B,UAAY,uBAEd,KAAAjG,gBAAgBK,GAAW,KACpC,CAGGmE,iBAAAA,CAAkBnE,GAEd,OAAA95B,KAAKy5B,gBAAgBK,GAASI,UAAA,CAclC8E,kBAAAA,CAAmB1O,EAAchlB,EAAkBnC,EAAoBi0B,GAEpE,aAAEO,EAAQhqB,QAAAA,GAAYypB,EAEtBuC,GAAOC,EAAAA,EAAAA,GAAwBt0B,GAE/B8vB,EAAWS,EAAAA,EAAkBgD,YAAYvO,GAAQ,IAAKhlB,GACtDgmB,EAAQ8J,EAAS9J,MACjBQ,EAAasJ,EAAStJ,WACtB+N,EAAazE,EAASyE,WACtBC,EAAe1E,EAAS0E,aACxBC,EAAiB3E,EAAS2E,eAE1Bh/B,EAAS48B,EAAO58B,OAQlB,GANJ4S,EAAQsY,iBACAtY,EAAA1J,MAAMd,EAAYA,GAC1BwK,EAAQqsB,aAAe10B,EAAM00B,aAIzB10B,EAAMylB,SAASjwB,MACnB,CACI,MAAMmsB,EAAc3hB,EAAMylB,QAE1Bpd,EAAQssB,UAAYhT,EAAYnsB,MAEhC6S,EAAQusB,WAAajT,EAAYiT,WACjCvsB,EAAQwsB,SAAWlT,EAAYrR,KAC/BjI,EAAQysB,QAAUnT,EAAYoT,GAAA,CAM9B,IAAAC,EACAC,EAHJ5sB,EAAQgsB,KAAOA,EAMT,MAAAa,EAAcl1B,EAAMgrB,WAAa,EAAI,EAa3C,IAAK,IAAIpwB,EAAI,EAAGA,EAAIs6B,IAAet6B,EACnC,CACU,MAAAu6B,EAAen1B,EAAMgrB,YAAoB,IAANpwB,EAEnCw6B,EAAeD,EAAe/2B,KAAKW,KAAKX,KAAKuG,IAAI,EAAGlP,GAA2B,EAAhBuK,EAAMjC,SAAgB,EACrFs3B,EAAiBD,EAAev3B,EAEtC,GAAIs3B,EACJ,CAII9sB,EAAQqZ,UAAY,QACpBrZ,EAAQsZ,YAAc,QAEtB,MAAM2T,EAAgBt1B,EAAMgrB,WAEtBuK,EAAkBD,EAAc9nB,MAChCgoB,EAAkBF,EAAc5tB,MAE9BW,EAAAotB,YAAcliB,EAAAA,EAAMpc,OACvBizB,SAASmL,GACT9J,SAAS+J,GACTE,eAEC,MAAAC,EAAiBL,EAAcvJ,KAAOluB,EACtC+3B,EAAqBN,EAAchO,SAAWzpB,EAEpDwK,EAAQwtB,WAAaF,EACrBttB,EAAQytB,cAAgB13B,KAAKwtB,IAAI0J,EAAczJ,OAAS+J,EACxDvtB,EAAQ0tB,cAAiB33B,KAAK0tB,IAAIwJ,EAAczJ,OAAS+J,EAAsBP,CAAA,MAI/EhtB,EAAQqZ,UAAY1hB,EAAM+lB,OAAQiQ,EAAAA,EAAAA,GAAmBh2B,EAAM+lB,MAAO1d,GAAW,KAEzErI,EAAMylB,SAASjwB,QAEf6S,EAAQsZ,aAAcqU,EAAAA,EAAAA,GAAmBh2B,EAAMylB,QAASpd,IAG5DA,EAAQotB,YAAc,QAGtB,IAAAQ,GAAsBzP,EAAaiO,EAAepN,UAAY,EAE9Db,EAAaiO,EAAepN,SAAW,IAElB4O,EAAA,GAGnB,MAAAC,EAAcl2B,EAAMylB,SAASjwB,OAAS,EAG5C,IAAK,IAAI2gC,EAAI,EAAGA,EAAInQ,EAAMjsB,OAAQo8B,IAE9BnB,EAAgBkB,EAAc,EAC9BjB,EAAkBiB,EAAc,EAAMC,EAAI3P,EAAeiO,EAAe2B,OAASH,EAE7D,UAAhBj2B,EAAM0qB,MAEWsK,GAAAR,EAAeD,EAAW4B,GAEtB,WAAhBn2B,EAAM0qB,QAEOsK,IAAAR,EAAeD,EAAW4B,IAAM,GAGlDn2B,EAAMylB,SAASjwB,OAEV,KAAA6gC,mBACDrQ,EAAMmQ,GACNn2B,EACA8xB,EACAkD,EAAgBh1B,EAAMjC,QACtBk3B,EAAgBj1B,EAAMjC,QAAUq3B,GAChC,QAIY,IAAhBp1B,EAAM+lB,OAED,KAAAsQ,mBACDrQ,EAAMmQ,GACNn2B,EACA8xB,EACAkD,EAAgBh1B,EAAMjC,QACtBk3B,EAAgBj1B,EAAMjC,QAAUq3B,EAG5C,CACJ,CAaIiB,kBAAAA,CACJrR,EACAhlB,EACA8xB,EACAtxB,EAAWC,GAGf,IAFI61B,EAAA5vB,UAAA3M,OAAA,QAAA4M,IAAAD,UAAA,IAAAA,UAAA,GAGM,cAAE2B,GAAYypB,EAGdrH,EAAgBzqB,EAAMyqB,cAE5B,IAAI8L,GAA+B,EAiB/B,GAfAhG,EAAAA,EAAkBiG,qCAEdjG,EAAAA,EAAkBkG,2BAEVpuB,EAAAoiB,cAAgB,GAAGA,MACnBpiB,EAAAquB,kBAAoB,GAAGjM,MACA8L,GAAA,IAI/BluB,EAAQoiB,cAAgB,MACxBpiB,EAAQquB,kBAAoB,QAId,IAAlBjM,GAAuB8L,EAWvB,YATID,EAEQjuB,EAAAsuB,WAAW3R,EAAMxkB,EAAGC,GAIpB4H,EAAAuuB,SAAS5R,EAAMxkB,EAAGC,IAMlC,IAAIo2B,EAAkBr2B,EAEhB,MAAAs2B,EAAcvG,EAAAA,EAAkBwG,kBAAkB/R,GACxD,IAAIgS,EAAgB3uB,EAAQkrB,YAAYvO,GAAMxvB,MAC1CyhC,EAAe,EAEnB,IAAK,IAAIr8B,EAAI,EAAGA,EAAIk8B,EAAY/8B,SAAUa,EAC1C,CACU,MAAAs8B,EAAcJ,EAAYl8B,GAE5B07B,EAEQjuB,EAAAsuB,WAAWO,EAAaL,EAAiBp2B,GAIzC4H,EAAAuuB,SAASM,EAAaL,EAAiBp2B,GAEnD,IAAI02B,EAAU,GAEd,IAAK,IAAI7vB,EAAI1M,EAAI,EAAG0M,EAAIwvB,EAAY/8B,SAAUuN,EAE1C6vB,GAAWL,EAAYxvB,GAEZ2vB,EAAA5uB,EAAQkrB,YAAY4D,GAAS3hC,MAC5CqhC,GAAmBG,EAAgBC,EAAexM,EAClCuM,EAAAC,CAAA,CACpB,CAGG/gC,OAAAA,GAEHxB,KAAKy5B,gBAAkB,MA3ZlBkF,EAGKl9B,UAAY,CACtBsC,KAAM,CACFrC,EAAAA,GAAcuN,YACdvN,EAAAA,GAAcwN,aACdxN,EAAAA,GAAcw8B,cAElB/5B,KAAM,cCpCdxB,EAAAA,GAAWR,IAAIw8B,GACfh8B,EAAAA,GAAWR,IAAIi8B,E,gDCCf,MAAMsE,EAAa,I,QAAIp0B,GAWhB,SAASovB,EACZvI,EACAr0B,EACAC,EACAoI,GAGA,MAAM3E,EAASk+B,EAEfl+B,EAAOoB,KAAO,EACdpB,EAAOqB,KAAO,EAEPrB,EAAAsB,KAAQqvB,EAAMr0B,MAAQqI,EAAc,EACpC3E,EAAAuB,KAAQovB,EAAMp0B,OAASoI,EAAc,EAE5C,MAAM2F,EAAUnE,EAAAA,EAAYC,kBACxBpG,EAAO1D,MACP0D,EAAOzD,OACPoI,GACA,GAmBG,OAhBP2F,EAAQ5F,OAAO80B,eAAiB,QAChClvB,EAAQ5F,OAAOi0B,SAAWhI,EAC1BrmB,EAAQ5F,OAAOw2B,UAAY,8BAEnB5wB,EAAA3B,MAAMrM,MAAQA,EAAQqI,EACtB2F,EAAA3B,MAAMpM,OAASA,EAASoI,EAOhC2F,EAAQ5F,OAAOy5B,KAAK,SAAU7zB,EAAQ5F,QAEtC4F,EAAQwD,YAEDxD,CACX,C","sources":["../node_modules/pixi.js/src/app/ResizePlugin.ts","../node_modules/pixi.js/src/app/TickerPlugin.ts","../node_modules/pixi.js/src/app/init.ts","../node_modules/pixi.js/src/filters/FilterPipe.ts","../node_modules/pixi.js/src/scene/container/bounds/getFastGlobalBounds.ts","../node_modules/pixi.js/src/filters/FilterSystem.ts","../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../node_modules/pixi.js/src/filters/init.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../node_modules/pixi.js/src/scene/graphics/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../node_modules/pixi.js/src/scene/mesh/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts","../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts","../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/init.ts","../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../node_modules/pixi.js/src/scene/sprite-tiling/init.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","../node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../node_modules/pixi.js/src/scene/text-bitmap/init.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","../node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","../node_modules/pixi.js/src/scene/text-html/HtmlTextStyle.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../node_modules/pixi.js/src/utils/browser/isSafari.ts","../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../node_modules/pixi.js/src/scene/text-html/init.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../node_modules/pixi.js/src/scene/text/init.ts","../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPlugin}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n// eslint-disable-next-line max-len\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.renderGroup)\n    {\n        bounds.applyMatrix(target.parentRenderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.renderGroup || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.parentRenderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.renderGroup)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? colorTextureSource._resolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= colorTextureSource.antialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        // need to factor in resolutions also..\n        bounds\n            .scale(resolution);\n\n        if (clipToViewport)\n        {\n            const viewPort = renderer.renderTarget.rootViewPort;\n\n            bounds.fitBounds(0, viewPort.width, 0, viewPort.height);\n        }\n\n        bounds\n            .ceil()\n            .scale(1 / resolution)\n            .pad(padding | 0);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","/* eslint-disable max-len */\nimport type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { RenderableGCSystem } from '../../../rendering/renderers/shared/texture/RenderableGCSystem';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderableGC: RenderableGCSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n\n        this.renderer.renderableGC.addManagedHash(this, '_graphicsBatchesHash');\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch._batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        graphics.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        if (this._graphicsBatchesHash[graphics.uid] === undefined)\n        {\n            // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n            graphics.on('destroyed', this._destroyRenderableBound);\n        }\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n\n        renderer.renderableGC.addManagedHash(this, '_gpuBatchableMeshHash');\n        renderer.renderableGC.addManagedHash(this, '_meshDataHash');\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n\n        mesh.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', this._destroyRenderableBound);\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n    private _textureMatrixUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPop.state;\n        const renderer = particleContainerPop.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPop.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPop.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPop.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer = outBuffer || new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer = outBuffer || new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n      \n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @property {number} size - The size of the particle buffer.\n * @property {Record<string, ParticleRendererProperty>} properties - A record of attributes that the particle container uses.\n */\nexport interface ParticleBufferOptions\n{\n    size: number;\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { ParticleContainer } from './ParticleContainer';\n\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @memberof scene\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    public adaptor: ParticleContainerAdaptor;\n    public readonly state = State.for2d();\n    public readonly renderer: Renderer;\n\n    private _gpuBufferHash: Record<number, ParticleBuffer> = Object.create(null);\n    // eslint-disable-next-line max-len\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as unknown as (renderable: Container) => void;\n\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        this._gpuBufferHash[renderable.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        renderable.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBufferHash[renderable.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public destroyRenderable(renderable: ParticleContainer)\n    {\n        const buffer = this._gpuBufferHash[renderable.uid];\n\n        buffer.destroy();\n\n        this._gpuBufferHash[renderable.uid] = null;\n\n        renderable.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n","import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPop.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPop.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPop.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPop.state;\n\n        const buffer = particleContainerPop.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPop.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuSpriteHash');\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableMesh = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableMesh.geometry as PoolItem);\n        BigPool.return(batchableMesh as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n\n        sprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = BigPool.get(BatchableMesh);\n\n        batchableMesh.geometry = BigPool.get(NineSliceGeometry);\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', this._destroyRenderableBound);\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Container } from '../container/Container';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_tilingSpriteDataHash');\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            // we are batching.. check a texture change!\n            if (batchableMesh && batchableMesh.texture._source !== renderable.texture._source)\n            {\n                return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n            }\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n\n        tilingSprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', this._destroyRenderableBound);\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite._applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { ViewContainer } from '../view/ViewContainer';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: ViewContainer;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer } from '../../view/ViewContainer';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends ViewContainer implements Instruction\n{\n    public override readonly renderPipeId: string = 'graphics';\n    public batched: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this._context.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n     * pattern object, or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     * or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyle object for advanced fills.\n     * @param {FillInput} style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a\n     * complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n     * complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise\n     * (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction.\n     * If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified,\n     * the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = getMaxTexturesPerBatch();\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBitmapText');\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        bitmapText.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        const context = this._gpuBitmapText[renderableUid].context;\n\n        if (context.customShader)\n        {\n            BigPool.return(context.customShader as PoolItem);\n\n            context.customShader = null;\n        }\n\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                context.customShader = BigPool.get(SdfShader);\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Container } from '../container/Container';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as HTMLText;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        htmlText.off('destroyed', this._destroyRenderableBound);\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.transform = htmlText.groupTransform;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        this._gpuText[htmlText.uid] = gpuTextData;\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HtmlTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: ConvertedStrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillInput, StrokeInput } from '../graphics/shared/FillTypes';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: StrokeInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: style.fontWeight,\n                        fontStyle: style.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height + descenderPadding - doublePadding,\n    };\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: HTMLImageElement | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as Text;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        text.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.transform = text.groupTransform;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n"],"names":["ResizePlugin","init","options","Object","defineProperty","this","set","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","add","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","extensions","FilterPipe","constructor","_renderer","push","filterEffect","container","instructionSet","renderPipes","batch","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","filter","type","WebGLPipes","WebGPUPipes","CanvasPipes","name","tempMatrix","Matrix","getFastGlobalBounds","target","bounds","clear","_getGlobalBoundsRecursive","isValid","renderGroup","applyMatrix","localTransform","parentRenderGroup","worldTransform","localDisplayStatus","measurable","manageEffects","effects","length","localBounds","boundsPool","boundsArea","addRect","viewBounds","addFrame","minX","minY","maxX","maxY","groupTransform","children","i","advanced","addBounds","copyTo","invert","relativeGroupTransform","return","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","offset","indexBuffer","Uint32Array","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","renderables","matrix","renderable","globalDisplayStatus","getGlobalRenderableBounds","filterArea","colorTextureSource","renderTarget","colorTexture","source","resolution","Infinity","padding","antialias","blendRequired","enabled","clipToViewport","Math","min","_resolution","compatibleRenderers","backBuffer","useBackBuffer","warn","scale","viewPort","rootViewPort","fitBounds","ceil","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","TexturePool","getOptimalTexture","bind","globalUniforms","Texture","EMPTY","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","style","apply","returnTexture","flip","flop","t","lastRenderSurface","backgroundResolution","x","y","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","rootRenderTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","frame","pixelWidth","pixelHeight","rootTexture","isRoot","update","uniformBatch","batchUniforms","getUboResource","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","Bounds","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","_source","prepend","texture","translate","anchor","WebGLSystem","WebGPUSystem","localUniformBit","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","blendModeIds","normal","multiply","screen","overlay","erase","max","_State","blendMode","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","default2d","State","count","textureOptions","_poolKeyHash","create","_texturePool","enableFullScreen","createTexture","textureSource","TextureSource","autoGarbageCollect","label","frameWidth","frameHeight","arguments","undefined","po2Width","po2Height","nextPow2","key","updateUvs","uid","getSameSizeTexture","renderTexture","destroyTextures","textures","j","color32BitToUniform","abgr","out","alpha","GraphicsPipe","adaptor","_graphicsBatchesHash","_destroyRenderableBound","destroyRenderable","_adaptor","renderableGC","addManagedHash","validateRenderable","graphics","context","wasBatched","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","didViewUpdate","_rebuild","_addToBatcher","updateRenderable","batches","_batcher","updateElement","_removeBatchForRenderable","off","isRenderable","getGpuContext","customShader","groupBlendMode","localUniforms","resources","uTransformMatrix","uRound","_roundPixels","groupColorAlpha","uColor","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","addToBatch","roundPixels","map","batchClone","BigPool","BatchableGraphics","on","graphicsUid","forEach","GraphicsContextSystem","MeshPipe","localUniformsBindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","_geometry","indices","indexSize","positions","vertexSize","batchableMesh","_getBatchableMesh","checkAndUpdateTexture","batcher","gpuBatchableMesh","_texture","gpuMesh","getAdjustedBlendModeBlend","_initMeshData","_initBatchableMesh","BatchableMesh","transform","batcherName","packAsQuad","indexOffset","attributeOffset","_batch","_uvUpdateId","_textureMatrixUpdateId","reset","uvs","uvBuffer","getBuffer","transformedUvs","textureMatrix","isSimple","_transformedUvs","_updateID","multiplyUvs","color","attributeSize","_MeshGeometry","deprecation","v8_0_0","defaultOptions","shrinkToFit","shrinkBuffersToFit","Buffer","usage","BufferUsage","VERTEX","COPY_DST","aUV","INDEX","batchMode","MeshGeometry","GlParticleContainerAdaptor","particleContainerPop","defaultShader","uTexture","gl","getBuffers","glProgram","glType","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","size","outBuffer","totalIndices","Uint16Array","Error","generateUpdateFunction","properties","dynamic","funcFragments","property","code","getAttributeInfoFromFormat","unshift","functionSource","join","Function","ParticleBuffer","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","_dynamicBuffer","addAttribute","attributeName","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","setDataWithSize","byteLength","float32View","uint32View","ParticleShader","Shader","GlProgram","from","fragment","gpuProgram","GpuProgram","wgsl","entryPoint","WHITE","uSampler","TextureStyle","uTranslationMatrix","Color","uResolution","ParticleContainerPipe","_gpuBufferHash","_renderable","_initBuffer","_properties","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe","_PlaneGeometry","super","verticesX","verticesY","build","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","PlaneGeometry","_NineSliceGeometry","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","updatePositions","w","scaleW","h","scaleH","_uvw","_uvh","NineSliceGeometry","NineSliceSpritePipe","_gpuSpriteHash","gpuSprite","_getGpuSprite","_updateBatchableSprite","batchableSprite","_initGPUSprite","tilingBit","tilingBitGl","TilingSpriteShader","compileHighShaderGpuProgram","bits","roundPixelsBit","compileHighShaderGlProgram","roundPixelsBitGl","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","a","b","c","d","tx","ty","mapCoord","QuadGeometry","sharedQuad","TilingSpritePipe","_tilingSpriteDataHash","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","tilingSprite","_updateBatchableMesh","bindGroup","_tileTransform","_initTilingSpriteData","slice","renderableData","addressMode","_applyAnchorToTexture","copyFrom","array","index","setUvs","setPositions","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isPowerOfTwo","BatchableSprite","_attributeStart","Graphics","ViewContainer","GraphicsContext","rest","_context","_ownedContext","onViewUpdate","allowChildren","containsPoint","point","_callContextMethod","method","args","setFillStyle","_len","Array","_key","setStrokeStyle","_len2","_key2","fill","_len3","_key3","stroke","_len4","_key4","_len5","_key5","beginPath","cut","arc","_len6","_key6","arcTo","_len7","_key7","arcToSvg","_len8","_key8","bezierCurveTo","_len9","_key9","closePath","ellipse","_len10","_key10","circle","_len11","_key11","path","_len12","_key12","lineTo","_len13","_key13","moveTo","_len14","_key14","quadraticCurveTo","_len15","_key15","rect","_len16","_key16","roundRect","_len17","_key17","poly","_len18","_key18","regularPoly","_len19","_key19","roundPoly","_len20","_key20","roundShape","_len21","_key21","filletRect","_len22","_key22","chamferRect","_len23","_key23","star","_len24","_key24","svg","_len25","_key25","restore","_len26","_key26","save","getTransform","resetTransform","rotateTransform","_len27","_key27","scaleTransform","_len28","_key28","setTransform","_len29","_key29","_len30","_key30","translateTransform","_len31","_key31","fillStyle","strokeStyle","clone","lineStyle","beginFill","endFill","defaultStrokeStyle","drawCircle","_len32","_key32","drawEllipse","_len33","_key33","drawPolygon","_len34","_key34","drawRect","_len35","_key35","drawRoundedRect","_len36","_key36","drawStar","_len37","_key37","localUniformMSDFBit","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","uDistance","maxTextures","getMaxTexturesPerBatch","colorBit","generateTextureBatchBit","colorBitGl","generateTextureBatchBitGl","batchSamplers","getBatchSamplersUniformGroup","BitmapTextPipe","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_didTextUpdate","_updateContext","syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","bitmapFont","BitmapFontManager","getFont","text","_style","distanceField","chars","currentY","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","offsetY","_stroke","_anchor","_x","_y","tint","applyFillAsTint","_fill","lines","line","charPositions","char","charData","round","xOffset","yOffset","lineHeight","initGpuText","proxyRenderable","fontFamily","dynamicFont","Cache","dx","sqrt","dy","worldScale","abs","fontScale","baseRenderedFontSize","fontSize","distance","range","proxy","groupColor","groupAlpha","HTMLTextPipe","_gpuText","runners","resolutionChange","gpuText","_autoResolution","htmlText","_getGpuText","newKey","_getKey","textureNeedsUploading","currentKey","_updateText","_destroyRenderableById","htmlTextUid","decreaseReferenceCount","_updateGpuText","catch","e","console","error","updateQuadBounds","generatingTexture","getManagedTexture","gpuTextData","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","image","Image","setAttribute","overflow","appendChild","textStyleToCSS","cssStyles","setValue","toHex","fontWeight","fontStyle","fontVariant","letterSpacing","align","whiteSpace","wordWrap","breakWords","wordWrapWidth","strokeToCSS","dropShadow","dropShadowToCSS","cssOverrides","tagStyles","tagStyle","cssTagStyle","templates","tagStyleToCSS","dropShadowStyle","setAlpha","toHexa","position","cos","angle","sin","blur","HTMLTextStyle","TextStyle","_cssOverrides","_generateKey","_styleKey","generateTextStyleKey","_cssStyle","cssStyle","addOverride","toAdd","v","includes","removeOverride","toRemove","loadFontCSS","url","dataSrc","response","DOMAdapter","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","result","onerror","readAsDataURL","loadFontAsBase64","FontStylePromiseCache","Map","tempHTMLTextRenderData","HTMLTextSystem","_activeTextures","_createCanvas","WEBGPU","getTexture","_buildTexturePromise","textKey","_increaseReferenceCount","promise","then","usageCount","htmlTextData","fontFamilies","dedupe","matches","match","addFontFamily","fontFamily2","isArray","split","trim","extractFontFamilies","fontCSS","fontPromises","has","all","getFontCss","defaultTextStyle","measured","fontStyleCSS","htmlTextRenderData","innerHTML","textContent","body","contentBounds","getBoundingClientRect","descenderPadding","CanvasTextMetrics","measureFont","descent","doublePadding","measureHtmlText","svgURL","XMLSerializer","serializeToString","getSVGUrl","delay","async","resolve2","setTimeout","onload","src","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","test","isSafari","resource","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","clearRect","drawImage","getTemporaryCanvasFromImage","getPo2TextureFromSource","canvas","initSource","returnCanvasAndContext","activeTexture","_cleanUp","uploadMethodId","getReferenceCount","CanvasSystem","defaultFontOptions","CanvasTextPipe","textUid","canvasText","checkRow","checkColumn","top","bottom","CanvasTextSystem","getTextureSize","measureText","_textKey","createTextureAndCanvas","renderTextToCanvas","trimmed","getContext","willReadFrequently","TypeError","getImageData","left","right","Rectangle","getCanvasBoundingBox","alphaMode","font","fontStringFromTextStyle","lineWidths","maxLineWidth","fontProperties","textBaseline","lineWidth","miterLimit","lineJoin","lineCap","cap","linePositionX","linePositionY","passesCount","isShadowPass","dsOffsetText","dsOffsetShadow","shadowOptions","dropShadowColor","dropShadowAlpha","shadowColor","toRgbaString","dropShadowBlur","dropShadowDistance","shadowBlur","shadowOffsetX","shadowOffsetY","getCanvasFillStyle","linePositionYShift","strokeWidth","i2","ascent","_drawLetterSpacing","isStroke","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","tempBounds","emit"],"sourceRoot":""}