{"version":3,"file":"static/js/862.42095ca7.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/app/ResizePlugin.ts","../node_modules/pixi.js/src/app/TickerPlugin.ts","../node_modules/pixi.js/src/app/init.ts","../node_modules/pixi.js/src/filters/FilterPipe.ts","../node_modules/pixi.js/src/scene/container/bounds/getFastGlobalBounds.ts","../node_modules/pixi.js/src/filters/FilterSystem.ts","../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../node_modules/pixi.js/src/filters/init.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/batchSamplersUniformGroup.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../node_modules/pixi.js/src/scene/graphics/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../node_modules/pixi.js/src/scene/mesh/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts","../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../node_modules/pixi.js/src/scene/sprite-tiling/init.ts","../node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts","../node_modules/pixi.js/src/scene/text/utils/generateTextStyleKey.ts","../node_modules/pixi.js/src/scene/text/TextStyle.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts","../node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontTextParser.ts","../node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLParser.ts","../node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts","../node_modules/pixi.js/src/scene/text-bitmap/asset/loadBitmapFont.ts","../node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../node_modules/pixi.js/src/scene/text-bitmap/init.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../node_modules/pixi.js/src/utils/browser/isSafari.ts","../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../node_modules/pixi.js/src/scene/text-html/init.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts","../node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts","../node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../node_modules/pixi.js/src/scene/text/init.ts","../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPluginOptions}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n// eslint-disable-next-line max-len\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.isRenderGroupRoot)\n    {\n        bounds.applyMatrix(target.renderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.isRenderGroupRoot || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.renderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.isRenderGroupRoot)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            location: 0,\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = colorTextureSource._resolution;\n\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for any filter, it should be true\n        let antialias = colorTextureSource.antialias;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias !== 'inherit')\n            {\n                if (filter.antialias === 'on')\n                {\n                    antialias = true;\n                }\n                else\n                {\n                    antialias = false;\n                }\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // her we constrain the bounds to the viewport we will render too\n        // need to factor in resolutions also..\n        bounds.scale(resolution)\n            .fit(renderer.renderTarget.rootViewPort)\n            .scale(1 / resolution)\n            .pad(padding)\n            .ceil();\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import { MAX_TEXTURES } from '../../../batcher/shared/const';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst sampleValues = new Int32Array(MAX_TEXTURES);\n\nfor (let i = 0; i < MAX_TEXTURES; i++)\n{\n    sampleValues[i] = i;\n}\n\nexport const batchSamplersUniformGroup = new UniformGroup({\n    uTextures: { value: sampleValues, type: `i32`, size: MAX_TEXTURES }\n}, { isStatic: true });\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const { width, height } = canvasAndContext.canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics._didGraphicsUpdate)\n        {\n            graphics._didGraphicsUpdate = false;\n\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch.batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            // TODO pool this!!\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        graphics.on('destroyed', () =>\n        {\n            this.destroyRenderable(graphics);\n        });\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport interface MeshInstruction extends Instruction\n{\n    renderPipeId: 'mesh';\n    mesh: Mesh;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<MeshInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add({\n                renderPipeId: 'mesh',\n                mesh\n            } as MeshInstruction);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        BigPool.return(gpuMesh as PoolItem);\n\n        this._gpuBatchableMeshHash[mesh.uid] = null;\n    }\n\n    public execute({ mesh }: MeshInstruction)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = mesh.groupBlendMode;\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', () =>\n        {\n            this.destroyRenderable(mesh);\n        });\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        gpuMesh.mesh = mesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Container } from '../../container/Container';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public mesh: Container;\n    public geometry: MeshGeometry;\n\n    public roundPixels: 0 | 1 = 0;\n\n    get blendMode() { return this.mesh.groupBlendMode; }\n\n    public reset()\n    {\n        this.mesh = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometry.indices;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indexBuffer[index++] = indices[i] + indicesOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const mesh = this.mesh;\n\n        const geometry = this.geometry;\n        const wt = mesh.groupTransform;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        // const trim = texture.trim;\n        const positions = geometry.positions;\n        const uvs = geometry.uvs;\n\n        const abgr = mesh.groupColorAlpha;\n\n        for (let i = 0; i < positions.length; i += 2)\n        {\n            const x = positions[i];\n            const y = positions[i + 1];\n\n            float32View[index] = (a * x) + (c * y) + tx;\n            float32View[index + 1] = (b * x) + (d * y) + ty;\n\n            // TODO implement texture matrix?\n            float32View[index + 2] = uvs[i];\n            float32View[index + 3] = uvs[i + 1];\n\n            uint32View[index + 4] = abgr;\n            uint32View[index + 5] = textureIdAndRound;\n\n            index += 6;\n        }\n    }\n\n    get vertexSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n    /** The texture matrix of the NineSlicePlane. */\n    textureMatrix?: Matrix\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private readonly _textureMatrix: Matrix = new Matrix();\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        if (options.textureMatrix)\n        {\n            this._textureMatrix.copyFrom(options.textureMatrix);\n        }\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const textureMatrix = this._textureMatrix;\n\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        multiplyUvs(textureMatrix, uvs);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\nfunction multiplyUvs(matrix: Matrix, uvs: Float32Array, out?: Float32Array)\n{\n    out ??= uvs;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    for (let i = 0; i < uvs.length; i += 2)\n    {\n        const x = uvs[i];\n        const y = uvs[i + 1];\n\n        out[i] = (x * a) + (y * c) + tx;\n        out[i + 1] = (x * b) + (y * d) + ty;\n    }\n\n    return out;\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, _instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        sprite._didSpriteUpdate = false;\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = new BatchableMesh();\n\n        batchableMesh.geometry = new NineSliceGeometry();\n\n        batchableMesh.mesh = sprite;\n\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(sprite);\n        });\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            vUV = (tilingUniforms.uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            vUV = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            // we are batching.. check a texture change!\n            if (batchableMesh.texture._source !== renderable.texture._source)\n\n            { return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture); }\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite._didTilingSpriteUpdate)\n            {\n                tilingSprite._didTilingSpriteUpdate = false;\n\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.mesh = tilingSprite;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: State.default2d,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite._didTilingSpriteUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh.batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite._didTilingSpriteUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n\n        tilingSprite._didTilingSpriteUpdate = false;\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(tilingSprite);\n        });\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite._applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): BitmapFontData['distanceField']['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): BitmapFontData['distanceField']['type']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            this.chars[i].texture.destroy();\n        }\n\n        (this.chars as null) = null;\n    }\n}\n","import type { FillGradient } from '../../graphics/shared/fill/FillGradient';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { TextStyle } from '../TextStyle';\n\nconst valuesToIterateForKeys = [\n    '_fontFamily',\n    '_fontStyle',\n    '_fontSize',\n    '_fontVariant',\n    '_fontWeight',\n    '_breakWords',\n    '_align',\n    '_leading',\n    '_letterSpacing',\n    '_lineHeight',\n    '_textBaseline',\n    '_whiteSpace',\n    '_wordWrap',\n    '_wordWrapWidth',\n    '_padding',\n    '_cssOverrides',\n    '_trim'\n];\n\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n */\nexport function generateTextStyleKey(style: TextStyle): string\n{\n    const key = [];\n\n    let index = 0;\n\n    for (let i = 0; i < valuesToIterateForKeys.length; i++)\n    {\n        const prop = valuesToIterateForKeys[i];\n\n        key[index++] = style[prop as keyof typeof style];\n    }\n\n    index = addFillStyleKey(style._fill, key as string[], index);\n    index = addStokeStyleKey(style._stroke, key as string[], index);\n\n    // TODO - we need to add some shadow stuff here!\n\n    return key.join('-');\n}\n\nfunction addFillStyleKey(fillStyle: ConvertedFillStyle, key: (number | string)[], index: number)\n{\n    if (!fillStyle) return index;\n\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = (fillStyle.fill as FillGradient)?.uid;\n\n    return index;\n}\n\nfunction addStokeStyleKey(strokeStyle: ConvertedStrokeStyle, key: (number | string)[], index: number)\n{\n    if (!strokeStyle) return index;\n\n    index = addFillStyleKey(strokeStyle, key, index);\n\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n\n    return index;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport { convertFillInputToFillStyle } from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillStyle,\n    FillStyleInputs\n} from '../graphics/shared/GraphicsContext';\n\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n// eslint-disable-next-line max-len\nexport type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * A collection of text related classes.\n * @namespace text\n */\n\n/**\n * A drop shadow effect.\n * @memberof text\n */\nexport type TextDropShadow = {\n    /** Set alpha for the drop shadow  */\n    alpha: number;\n    /** Set a angle of the drop shadow */\n    angle: number;\n    /** Set a shadow blur radius */\n    blur: number;\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n    color: ColorSource;\n    /** Set a distance of the drop shadow */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances.\n * ```js\n * const textStyle = new TextStyle({\n *    fontSize: 12,\n *    fill: 'black',\n * });\n * ```\n * @see {@link text.TextStyle}\n * @memberof text\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align?: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs `wordWrap` to be set to `true` */\n    breakWords?: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill?: FillStyleInputs;\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    fontFamily?: string | string[];\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    fontSize?: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke?: FillStyleInputs;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline?: TextStyleTextBaseline;\n    trim?: boolean,\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n}\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @memberof text\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /** The default drop shadow settings */\n    public static defaultDropShadow: TextDropShadow = {\n        /** Set alpha for the drop shadow */\n        alpha: 1,\n        /** Set a angle of the drop shadow */\n        angle: Math.PI / 6,\n        /** Set a shadow blur radius */\n        blur: 0,\n        /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n        color: 'black',\n        /** Set a distance of the drop shadow */\n        distance: 5,\n    };\n\n    /** The default text style settings */\n    public static defaultTextStyle: TextStyleOptions = {\n        /**\n         * See {@link TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link TextStyle.dropShadow} */\n        dropShadow:  null,\n        /**\n         * See {@link TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link TextStyle.fontSize}\n         * @type {number|string}\n         */\n        fontSize: 26,\n        /**\n         * See {@link TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link TextStyle.leading} */\n        leading: 0,\n        /** See {@link TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link TextStyle.lineHeight} */\n        lineHeight: 0,\n        /** See {@link TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: null,\n        /**\n         * See {@link TextStyle.textBaseline}\n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillStyleInputs;\n\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: FillStyleInputs;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n\n    private _padding: number;\n\n    protected _styleKey: string;\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = {\n                ...TextStyle.defaultDropShadow as TextDropShadow,\n                ...value as TextDropShadow\n            };\n        }\n        else\n        {\n            this._dropShadow = value ? {\n                ...TextStyle.defaultDropShadow as TextDropShadow\n            } : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle) { this._fontStyle = value; this.update(); }\n    /**\n     * The font variant.\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n    get fill(): FillStyleInputs\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillStyleInputs)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n        this._fill = convertFillInputToFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): FillStyleInputs\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: FillStyleInputs)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n        this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    protected _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this);\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._styleKey = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    get styleKey()\n    {\n        return this._styleKey || this._generateKey();\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n        });\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as any;\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n\n        style.stroke = {\n            color,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fill))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        const gradientFill = new FillGradient(0, 0, 0, (style.fontSize as number) * 1.7);\n\n        const fills: number[] = oldStyle.fill.map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fills.forEach((number, index) =>\n        {\n            const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n\n            gradientFill.addColorStop(ratio, number);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { TextStyle } from '../text/TextStyle';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 4;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        const widthScale = style.fontStyle === 'italic' ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps heigh\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = (widthScale * metrics.width) * fontScale;\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = width + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > 512)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > 512)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload'\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(chars: string[], style: TextStyle, font: AbstractBitmapFont<any>): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n        let lastChar = currentLine.chars[index];\n\n        while (lastChar === ' ')\n        {\n            currentLine.width -= font.chars[lastChar].xAdvance;\n            lastChar = currentLine.chars[--index];\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill)\n        {\n            fontFamilyKey += style._fill.fill.uid;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fnt.once('destroy', () => Cache.remove(fontFamilyKey));\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     */\n    public getLayout(text: string, style: TextStyle): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout(text.split(''), style, bitmapFont);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     */\n    public measureText(text: string, style: TextStyle): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            Cache.remove(cacheKey);\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","import { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont.\n * @memberof text\n */\nexport interface BitmapFontOptions\n{\n    data: BitmapFontData\n    textures: Texture[]\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * @memberof text\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /** the url of the font */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const textureSource = textures[charData.page].source;\n\n            const frameReal = new Rectangle(\n                charData.x,\n                charData.y,\n                charData.width,\n                charData.height,\n            );\n\n            const texture = new Texture({\n                source: textureSource,\n                frame: frameReal\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParser } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const bitmapFontCachePlugin = {\n    extension: ExtensionType.CacheParser,\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n};\n\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push(imagePath);\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    unload(bitmapFont: BitmapFont): void\n    {\n        bitmapFont.destroy();\n    }\n} as LoaderParser;\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Container } from '../../container/Container';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillStyle, FillStyleInputs, StrokeStyle } from './GraphicsContext';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends Container implements View, Instruction\n{\n    public readonly canBundle = true;\n    public readonly renderPipeId = 'graphics';\n    public batched: boolean;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    public _didGraphicsUpdate: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this._context.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the graphic.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    protected onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didGraphicsUpdate = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillStyleInputs): this;\n    public fill(...args: [FillStyleInputs, ColorSource?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /** Begins a new path. */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    public cut(...args: Parameters<GraphicsContext['cut']>): this\n    {\n        return this._callContextMethod('cut', args);\n    }\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    public closePath(...args: Parameters<GraphicsContext['closePath']>): this\n    {\n        return this._callContextMethod('closePath', args);\n    }\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    public save(...args: Parameters<GraphicsContext['save']>): this\n    {\n        return this._callContextMethod('save', args);\n    }\n    public getTransform(...args: Parameters<GraphicsContext['getTransform']>): this\n    {\n        return this._callContextMethod('getTransform', args);\n    }\n    public resetTransform(...args: Parameters<GraphicsContext['resetTransform']>): this\n    {\n        return this._callContextMethod('resetTransform', args);\n    }\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    public clear(...args: Parameters<GraphicsContext['clear']>): this\n    {\n        return this._callContextMethod('clear', args);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillStyleInputs)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: FillStyleInputs)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n\n    }\n};\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { batchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/batchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(MAX_TEXTURES),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(MAX_TEXTURES),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: batchSamplersUniformGroup,\n            }\n        });\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private _sdfShader: SdfShader;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                if (!this._sdfShader)\n                {\n                    this._sdfShader = new SdfShader();\n                }\n\n                context.customShader = this._sdfShader;\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = (style._stroke?.width || 0) / 2;\n\n        currentY += bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        context\n            .translate(\n                (-bitmapText._anchor._x * bitmapTextLayout.width) - padding,\n                (-bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY)) - padding)\n            .scale(scale, scale);\n\n        const tint = style._fill.color;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint,\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that hav the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', () =>\n        {\n            this.destroyRenderable(bitmapText);\n        });\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const resolution = bitmapText.resolution ?? this._renderer.resolution;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._sdfShader?.destroy(true);\n        this._sdfShader = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from './asset/loadBitmapFont';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText._onUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        this._gpuText[htmlText.uid] = gpuTextData;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', () =>\n        {\n            this.destroyRenderable(htmlText);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { HTMLTextRenderData } from '../HTMLTextSystem';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding,\n    };\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\nconst nssvg = 'http://www.w3.org/2000/svg';\nconst nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(fontFamilies, style);\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        image.width = width | 0;\n        image.height = height | 0;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        let resource: HTMLImageElement | HTMLCanvasElement = image;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            resource = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { FontStylePromiseCache, HTMLTextSystem } from '../HTMLTextSystem';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The style to load the font with (used for the first font family)\n * @returns - The css string\n */\nexport async function getFontCss(fontFamilies: string[], style: HTMLTextStyle)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(fontFamily))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(fontFamily);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        ...HTMLTextSystem.defaultFontOptions,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import type { HTMLTextStyle } from '../HtmlTextStyle';\nimport type { HTMLTextRenderData } from '../HTMLTextSystem';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * This canvas is immediately returned to the CanvasPool for reuse, so use the result straight away!\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): HTMLCanvasElement\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas and context to the CanvasPool.\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n    // Return the canvas.\n    return canvasAndContext.canvas as HTMLCanvasElement;\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @memberof text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { TextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = TextMetrics.measureText('Your text', style);\n * @memberof text\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|ÉqÅ';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    private static readonly _measurementCache: Record<string, CanvasTextMetrics> = {};\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}:${style.styleKey}`;\n\n        // TODO - if we find this starts to go nuts with memory, we can remove the cache\n        // or instead just stick a usage tick that we increment each time we return it.\n        // if some are not used, we can just tidy them up!\n        if (CanvasTextMetrics._measurementCache[textKey]) return CanvasTextMetrics._measurementCache[textKey];\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth * 2))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // CanvasTextMetrics._measurementCache[textKey] = measurements;\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        let width = context.measureText(text).width;\n\n        if (width > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                width -= letterSpacing;\n            }\n            else\n            {\n                width += (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n            }\n        }\n\n        return width;\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convienience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (ex)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n","import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/GraphicsContext';\n\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D): string | CanvasGradient | CanvasPattern\n{\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).toHex();\n    }\n    else if (!fillStyle.fill)\n    {\n        // fancy set up...\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n\n        // create an inverted scale matrix..\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill as FillPattern;\n\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill as FillGradient;\n\n        if (fillGradient.type === 'linear')\n        {\n            const gradient = context.createLinearGradient(\n                fillGradient.x0,\n                fillGradient.y0,\n                fillGradient.x1,\n                fillGradient.y1\n            );\n\n            fillGradient.gradientStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n\n            return gradient;\n        }\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            const resolution = text.resolution ?? this._renderer.resolution;\n\n            const { width, height } = this._renderer.canvasText.getTextureSize(\n                text.text,\n                resolution,\n                text._style,\n            );\n\n            if (\n                // is only being used by this text:\n                this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1\n                // check the size of the text is the same po2\n                && width === gpuText.texture._source.width\n                && height === gpuText.texture._source.height\n            )\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, _instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        const resolution = text.resolution ?? this._renderer.resolution;\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(\n            text.text,\n            resolution,\n            text._style,\n            text._getKey()\n        );\n\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', () =>\n        {\n            this.destroyRenderable(text);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { TextStyle } from '../TextStyle';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string)\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n"],"names":["ResizePlugin","init","options","Object","defineProperty","this","set","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","add","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","extensions","FilterPipe","constructor","_renderer","push","filterEffect","container","instructionSet","renderPipes","batch","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","filter","type","WebGLPipes","WebGPUPipes","CanvasPipes","name","tempMatrix","Matrix","getFastGlobalBounds","target","bounds","clear","_getGlobalBoundsRecursive","isValid","isRenderGroupRoot","applyMatrix","renderGroup","localTransform","worldTransform","localDisplayStatus","measurable","manageEffects","effects","length","localBounds","boundsPool","boundsArea","addRect","viewBounds","addFrame","minX","minY","maxX","maxY","groupTransform","children","i","advanced","addBounds","copyTo","invert","relativeGroupTransform","return","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","location","format","stride","offset","indexBuffer","Uint32Array","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_this$_activeFilterDa","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","renderables","matrix","renderable","globalDisplayStatus","getGlobalRenderableBounds","filterArea","colorTextureSource","renderTarget","rootRenderTarget","colorTexture","source","resolution","_resolution","padding","antialias","blendRequired","enabled","_renderer$backBuffer$","_renderer$backBuffer","Math","min","compatibleRenderers","backBuffer","useBackBuffer","warn","scale","fit","rootViewPort","pad","ceil","isPositive","previousRenderSurface","renderSurface","inputTexture","TexturePool","getOptimalTexture","bind","globalUniforms","Texture","EMPTY","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","style","apply","returnTexture","flip","flop","t","lastRenderSurface","backgroundResolution","x","y","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","frame","pixelWidth","pixelHeight","rootTexture","isRoot","update","uniformBatch","batchUniforms","getUboResource","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","Bounds","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","_source","prepend","texture","translate","anchor","WebGLSystem","WebGPUSystem","sampleValues","Int32Array","MAX_TEXTURES","batchSamplersUniformGroup","uTextures","size","isStatic","CanvasPool","canvasOptions","_canvasPool","create","enableFullScreen","_createCanvasAndContext","canvas","DOMAdapter","createCanvas","context","getContext","getOptimalCanvasAndContext","minWidth","minHeight","arguments","undefined","key","nextPow2","canvasAndContext","returnCanvasAndContext","GraphicsPipe","adaptor","State","for2d","_graphicsBatchesHash","_adaptor","validateRenderable","graphics","wasBatched","uid","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","_didGraphicsUpdate","_rebuild","_addToBatcher","updateRenderable","batches","batcher","updateElement","destroyRenderable","_removeBatchForRenderable","isRenderable","getGpuContext","customShader","blendMode","groupBlendMode","localUniforms","resources","uTransformMatrix","uRound","_roundPixels","color32BitToUniform","groupColorAlpha","uColor","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","addToBatch","roundPixels","map","batchClone","BigPool","BatchableGraphics","on","graphicsUid","forEach","GraphicsContextSystem","MeshPipe","localUniformsBindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","_geometry","indices","indexSize","positions","vertexSize","batchableMesh","_getBatchableMesh","checkAndUpdateTexture","gpuBatchableMesh","_texture","gpuMesh","_ref","_initMeshData","_mesh$_geometry$indic","_mesh$_geometry$posit","_initBatchableMesh","BatchableMesh","reset","packIndex","index","indicesOffset","packAttributes","float32View","uint32View","textureId","wt","textureIdAndRound","a","b","c","d","tx","ty","uvs","abgr","_MeshGeometry","deprecation","v8_0_0","defaultOptions","shrinkToFit","shrinkBuffersToFit","Buffer","label","usage","BufferUsage","VERTEX","COPY_DST","aUV","INDEX","batchMode","MeshGeometry","_PlaneGeometry","super","verticesX","verticesY","build","_this$verticesX","_this$verticesY","_this$width","_this$height","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","PlaneGeometry","_NineSliceGeometry","_textureMatrix","_options$width","_options$height","_options$originalWidt","_options$originalHeig","_options$leftWidth","_options$rightWidth","_options$topHeight","_options$bottomHeight","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","textureMatrix","copyFrom","updateUvs","updatePositions","w","scaleW","h","scaleH","getBuffer","_uvw","_uvh","out","_out","multiplyUvs","NineSliceGeometry","NineSliceSpritePipe","_gpuSpriteHash","_instructionSet","gpuSprite","_getGpuSprite","_didSpriteUpdate","_updateBatchableSprite","batchableSprite","_initGPUSprite","tilingBit","vertex","header","main","fragment","tilingBitGl","gpuProgram","glProgram","TilingSpriteShader","Shader","_gpuProgram","_glProgram","compileHighShaderGpuProgram","bits","localUniformBit","roundPixelsBit","compileHighShaderGlProgram","localUniformBitGl","roundPixelsBitGl","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","uTexture","uSampler","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","mapCoord","QuadGeometry","sharedQuad","TilingSpritePipe","_tilingSpriteDataHash","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","tilingSprite","_didTilingSpriteUpdate","_updateBatchableMesh","bindGroup","default2d","_tileTransform","_tilingSpriteData$sha","_initTilingSpriteData","slice","renderableData","addressMode","_applyAnchorToTexture","array","setUvs","setPositions","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isSimple","isPowerOfTwo","AbstractBitmapFont","EventEmitter","chars","lineHeight","fontFamily","fontMetrics","fontSize","ascent","descent","baseLineOffset","distanceField","range","pages","baseMeasurementFontSize","baseRenderedFontSize","font","pageTextures","distanceFieldRange","distanceFieldType","emit","removeAllListeners","valuesToIterateForKeys","generateTextStyleKey","prop","addFillStyleKey","_fill","strokeStyle","alignment","cap","join","miterLimit","addStokeStyleKey","_stroke","fillStyle","_fillStyle$fill","color","alpha","fill","_TextStyle","oldStyle","dropShadow","_oldStyle$dropShadowA","_oldStyle$dropShadowA2","_oldStyle$dropShadowB","_oldStyle$dropShadowC","_oldStyle$dropShadowD","defaults","TextStyle","defaultDropShadow","dropShadowAlpha","angle","dropShadowAngle","blur","dropShadowBlur","dropShadowColor","distance","dropShadowDistance","strokeThickness","stroke","Array","isArray","gradientFill","FillGradient","fills","Color","setValue","toNumber","number","_oldStyle$fillGradien","ratio","fillGradientStops","addColorStop","convertV7Tov8Style","fullStyle","defaultTextStyle","align","_align","breakWords","_breakWords","_dropShadow","_fontFamily","_fontSize","parseInt","fontStyle","_fontStyle","fontVariant","_fontVariant","fontWeight","_fontWeight","leading","_leading","letterSpacing","_letterSpacing","_lineHeight","_padding","trim","_trim","textBaseline","_textBaseline","whiteSpace","_whiteSpace","wordWrap","_wordWrap","wordWrapWidth","_wordWrapWidth","_originalFill","convertFillInputToFillStyle","GraphicsContext","defaultFillStyle","_originalStroke","defaultStrokeStyle","_generateKey","_styleKey","defaultStyle","styleKey","clone","_this$_fill","_this$_originalFill","_this$_stroke","_this$_originalStroke","destroyTextureSource","textureSource","PI","resolveCharacters","result","j","item","Error","concat","startCode","charCodeAt","endCode","i2","j2","String","fromCharCode","from","DynamicBitmapFont","_dynamicOptions$skipK","_dynamicOptions$resol","_dynamicOptions$paddi","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","overrideFill","WHITE","requestedFontSize","fontStringFromTextStyle","overrideSize","_style","skipKerning","CanvasTextMetrics","measureFont","ensureCharacters","charList","char","includes","self","indexOf","pageData","_nextPage","currentX","currentY","fontScale","widthScale","maxCharHeight","skipTexture","_style$dropShadow$dis","_style$dropShadow","_style$_stroke$width","_style$_stroke","metrics","measureText","paddedWidth","paddedHeight","max","pageData2","xAdvance","id","codePointAt","xOffset","yOffset","kerning","_drawGlyph","px","py","Rectangle","_applyKerning","newChars","measureCache","first","second","c1","c2","amount","textureResolution","_setupContext","ImageSource","resource","alphaMode","_stroke$width","lineWidth","lineJoin","getCanvasFillStyle","shadowOptions","rgb","toArray","shadowColor","shadowBlur","shadowOffsetX","cos","shadowOffsetY","sin","_stroke$width2","text","fontProperties","strokeText","fillText","getBitmapTextLayout","layoutData","offsetY","lines","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","position","nextLine","lastChar","adjustedLetterSpacing","adjustedWordWrapWidth","isEnd","charData","test","nextCharWidth","measurementData","line","alignCenter","alignRight","indy","spaceIndex","totalSpaces","alignJustify","BitmapFontManager","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","getFont","_dynamicFont$ensureCh","fontFamilyKey","Cache","has","fnt","once","dynamicFont","call","getLayout","bitmapFont","split","install","_options","_ref2","_ref3","_ref4","textStyle","flatChars","uninstall","cacheKey","BitmapFont","url","_data$distanceField","textures","keys","_charData$kerning","page","frameReal","bitmapFontTextParser","startsWith","parse","txt","_rawData$distanceFiel","items","match","rawData","info","common","kernings","attributeList","itemData","strValue","replace","floatValue","parseFloat","isNaN","distanceRange","fieldType","face","file","base","_charNode$letter","charNode","letter","xoffset","yoffset","xadvance","bitmapFontXMLParser","xml","getElementsByTagName","getAttribute","_charNode$getAttribut","bitmapFontXMLStringParser","parseXML","validExtensions","bitmapFontCachePlugin","CacheParser","asset","getCacheableAssets","loadBitmapFont","LoadParser","priority","LoaderParserPriority","Normal","path","extname","toLowerCase","async","loader","bitmapFontData","src","textureUrls","pageFile","imagePath","dirname","copySearchParams","loadedTextures","load","response","fetch","unload","Graphics","Container","rest","_context","_ownedContext","onViewUpdate","allowChildren","off","containsPoint","point","_didChangeId","didViewUpdate","onChildViewUpdate","_callContextMethod","method","args","setFillStyle","_len","_key","setStrokeStyle","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","beginPath","cut","_len6","_key6","arc","_len7","_key7","arcTo","_len8","_key8","arcToSvg","_len9","_key9","bezierCurveTo","_len10","_key10","closePath","_len11","_key11","ellipse","_len12","_key12","circle","_len13","_key13","_len14","_key14","lineTo","_len15","_key15","moveTo","_len16","_key16","quadraticCurveTo","_len17","_key17","rect","_len18","_key18","roundRect","_len19","_key19","poly","_len20","_key20","regularPoly","_len21","_key21","roundPoly","_len22","_key22","roundShape","_len23","_key23","filletRect","_len24","_key24","chamferRect","_len25","_key25","star","_len26","_key26","svg","_len27","_key27","restore","_len28","_key28","save","_len29","_key29","getTransform","_len30","_key30","resetTransform","_len31","_key31","rotateTransform","_len32","_key32","scaleTransform","_len33","_key33","setTransform","_len34","_key34","transform","_len35","_key35","translateTransform","_len36","_key36","_len37","_key37","lineStyle","beginFill","endFill","drawCircle","_len38","_key38","drawEllipse","_len39","_key39","drawPolygon","_len40","_key40","drawRect","_len41","_key41","drawRoundedRect","_len42","_key42","drawStar","_len43","_key43","localUniformMSDFBit","end","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","uDistance","colorBit","generateTextureBatchBit","colorBitGl","generateTextureBatchBitGl","batchSamplers","BitmapTextPipe","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_didTextUpdate","_updateContext","syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","_sdfShader","bitmapTextLayout","_anchor","_x","_y","tint","round","initGpuText","proxyRenderable","_bitmapText$resolutio","dx","sqrt","dy","worldScale","abs","_this$_sdfShader","proxy","groupColor","groupAlpha","HTMLTextPipe","_gpuText","htmlText","gpuText","_getGpuText","newKey","_getKey","textureNeedsUploading","currentKey","_updateText","_destroyRenderableById","htmlTextUid","decreaseReferenceCount","_updateGpuText","catch","e","console","error","updateQuadBounds","_htmlText$resolution","generatingTexture","getManagedTexture","_onUpdate","gpuTextData","BatchableSprite","loadFontCSS","dataSrc","blob","reader","FileReader","Promise","resolve","reject","onloadend","onerror","readAsDataURL","loadFontAsBase64","tempHTMLTextRenderData","nssvg","nsxhtml","FontStylePromiseCache","Map","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","image","Image","setAttribute","overflow","appendChild","HTMLTextSystem","_activeTextures","_createCanvas","WEBGPU","getTexture","_buildTexturePromise","textKey","_increaseReferenceCount","promise","then","usageCount","htmlTextData","fontFamilies","dedupe","matches","addFontFamily","fontFamily2","tagStyles","extractFontFamilies","fontCSS","fontPromises","defaultFontOptions","all","getFontCss","measured","fontStyleCSS","htmlTextRenderData","innerHTML","cssStyle","textContent","body","contentBounds","getBoundingClientRect","descenderPadding","measureHtmlText","svgURL","toString","XMLSerializer","serializeToString","getSVGUrl","delay","resolve2","setTimeout","onload","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","isSafari","clearRect","drawImage","getTemporaryCanvasFromImage","getPo2TextureFromSource","initSource","activeTexture","_cleanUp","uploadMethodId","getReferenceCount","CanvasSystem","contextSettings","willReadFrequently","_CanvasTextMetrics","experimentalLetterSpacingSupported","_experimentalLetterSpacingSupported","proto","getCanvasRenderingContext2D","prototype","lineWidths","maxLineWidth","_canvas","_measurementCache","__context","_measureText","strokeWidth","useExperimentalLetterSpacing","experimentalLetterSpacing","textLetterSpacing","graphemeSegmenter","cache","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","characters","wordWrapSplit","k","nextChar","canBreakChars","characterWidth","isLastToken","newLine","_trimRight","_newlines","_nextChar","_breakingSpaces","_token","_char","_index","_fonts","METRICS_STRING","BASELINE_SYMBOL","properties","actualBoundingBoxAscent","actualBoundingBoxDescent","clearMetrics","__canvas","OffscreenCanvas","ex","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","_Intl","Intl","Segmenter","segmenter","s","segment","genericFontFamilies","fontSizeString","toHex","pattern","createPattern","FillPattern","fillPattern","fillGradient","gradient","createLinearGradient","x0","y0","x1","y1","gradientStops","CanvasTextPipe","_text$resolution","canvasText","getTextureSize","textUid","_text$resolution2","checkRow","checkColumn","top","bottom","CanvasTextSystem","renderTextToCanvas","trimmed","TypeError","getImageData","left","right","getCanvasBoundingBox","lineCap","linePositionX","linePositionY","passesCount","_style$_stroke3","isShadowPass","dsOffsetText","dsOffsetShadow","setAlpha","toRgbaString","_style$_fill$alpha","_style$_fill","_style$_stroke2","globalAlpha","linePositionYShift","_drawLetterSpacing","isStroke","currentPosition","stringArray","previousWidth","currentWidth","currentChar","textStr","tempBounds"],"sourceRoot":""}